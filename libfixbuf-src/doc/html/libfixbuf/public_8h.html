
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>fixbuf- Documentation</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
        <link rel="stylesheet" type="text/css" href="../../site/style.css" />
        <link rel="stylesheet" type="text/css" href="doxygen.css">
        <link rel="stylesheet" type="text/css" href="tabs.css">
</head>
<body>
    <div id="p-body">
      <div id="l-header">
        <img src="../../site/sei-logo.png" id="l-sei-logo"
            alt="Software Engineering Institute | Carnegie Mellon&copy;" />
        <div id="l-netsa-logo"><a id="l-netsa-name" href="../../index.html"><b>CERT NetSA Security Suite</b></a></div>
        <div id="l-netsa-motto">Monitoring for Large-Scale Networks</div>
        <h1 class="l-page-title">fixbuf</h1>
        <span id="l-subtitle">Documentation</span>
      </div><!-- l-header -->
      <div id="l-content">
        <div id="l-sidebar">
          <div class="p-sidebar-section">
            <h1><a href="../index.html">fixbuf</a></h1>
            <ul>
              <li><a href="index.html">Documentation</a></li>
              <li><a href="../download.html">Downloads</a></li>
	      <li><a href="../../pyfixbuf/index.html">pyfixbuf</a></li>
            </ul>
          </div><!-- p-sidebar-section -->
        </div><!-- l-sidebar -->
      <div id="top"> <!-- need this for doxygen -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_a5abd3b1eb70c29b5be27a256b50434a.html">fixbuf</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">public.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Fixbuf IPFIX protocol library public interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;fixbuf/autoinc.h&gt;</code><br />
</div>
<p><a href="public_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_varfield__st.html">fbVarfield_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable-length field value.  <a href="structfb_varfield__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_info_model_iter__st.html">fbInfoModelIter_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over the information elements in an information model.  <a href="structfb_info_model_iter__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_info_element__st.html">fbInfoElement_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single IPFIX Information Element definition.  <a href="structfb_info_element__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_info_element_opt_rec__st.html">fbInfoElementOptRec_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corresponding struct to the Information Element Type Options Template.  <a href="structfb_info_element_opt_rec__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_info_element_spec__st.html">fbInfoElementSpec_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single IPFIX Information Element specification.  <a href="structfb_info_element_spec__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_conn_spec__st.html">fbConnSpec_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection specifier.  <a href="structfb_conn_spec__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_listener_entry__st.html">fbListenerEntry_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ListenerEntry's make up a listener group as a linked list.  <a href="structfb_listener_entry__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_listener_group_result__st.html">fbListenerGroupResult_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ListenerGroupResult's contain the listener who's listening socket got a new connection.  <a href="structfb_listener_group_result__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_basic_list__st.html">fbBasicList_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic list element in a template which structure represents a basic list on the internal side, basic lists in an IPFIX Message must be represented by this structure within the application record.  <a href="structfb_basic_list__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used to hold information of a sub template list.  <a href="structfb_sub_template_list__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entries contain the same type of information at SubTemplateLists: template ID and template pointers to describe the data the number of data elements and the data pointer and data length.  <a href="structfb_sub_template_multi_list_entry__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multilists just contain the semantic to describe the sub lists, the number of sub lists, and a pointer to the first entry.  <a href="structfb_sub_template_multi_list__st.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9ee0139d4776e3b83dc6a2854752f96f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>FIXBUF_CHECK_VERSION</b>(major,  minor,  release)</td></tr>
<tr class="separator:a9ee0139d4776e3b83dc6a2854752f96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16875886e559694c2a5d80cc1b9e00de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a16875886e559694c2a5d80cc1b9e00de">FB_ERROR_DOMAIN</a>&#160;&#160;&#160;g_quark_from_string(&quot;fixbufError&quot;)</td></tr>
<tr class="memdesc:a16875886e559694c2a5d80cc1b9e00de"><td class="mdescLeft">&#160;</td><td class="mdescRight">All fixbuf errors are returned within the FB_ERROR_DOMAIN domain.  <a href="#a16875886e559694c2a5d80cc1b9e00de">More...</a><br /></td></tr>
<tr class="separator:a16875886e559694c2a5d80cc1b9e00de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fea2f3d2282f4130b0762bfdf4cdc8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af9fea2f3d2282f4130b0762bfdf4cdc8">FB_ERROR_TMPL</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:af9fea2f3d2282f4130b0762bfdf4cdc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">No template was available for the given template ID.  <a href="#af9fea2f3d2282f4130b0762bfdf4cdc8">More...</a><br /></td></tr>
<tr class="separator:af9fea2f3d2282f4130b0762bfdf4cdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0259831c04ac6aeee7cb6c96d76b3d65"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a0259831c04ac6aeee7cb6c96d76b3d65">FB_ERROR_EOM</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a0259831c04ac6aeee7cb6c96d76b3d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of IPFIX message.  <a href="#a0259831c04ac6aeee7cb6c96d76b3d65">More...</a><br /></td></tr>
<tr class="separator:a0259831c04ac6aeee7cb6c96d76b3d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367b1a2c0af72830b0c9905b2db317cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a367b1a2c0af72830b0c9905b2db317cb">FB_ERROR_EOF</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a367b1a2c0af72830b0c9905b2db317cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of IPFIX Message stream.  <a href="#a367b1a2c0af72830b0c9905b2db317cb">More...</a><br /></td></tr>
<tr class="separator:a367b1a2c0af72830b0c9905b2db317cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa225780afc0e4680caf26e0ec9ab2427"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa225780afc0e4680caf26e0ec9ab2427">FB_ERROR_IPFIX</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:aa225780afc0e4680caf26e0ec9ab2427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Illegal IPFIX mesaage content on read.  <a href="#aa225780afc0e4680caf26e0ec9ab2427">More...</a><br /></td></tr>
<tr class="separator:aa225780afc0e4680caf26e0ec9ab2427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0ffd43c861a9833b279557d687c57a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a2e0ffd43c861a9833b279557d687c57a">FB_ERROR_BUFSZ</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a2e0ffd43c861a9833b279557d687c57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A message was received larger than the collector buffer size.  <a href="#a2e0ffd43c861a9833b279557d687c57a">More...</a><br /></td></tr>
<tr class="separator:a2e0ffd43c861a9833b279557d687c57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25725f494c04fdab230c546953bdda9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af25725f494c04fdab230c546953bdda9">FB_ERROR_IMPL</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:af25725f494c04fdab230c546953bdda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The requested feature is not yet implemented.  <a href="#af25725f494c04fdab230c546953bdda9">More...</a><br /></td></tr>
<tr class="separator:af25725f494c04fdab230c546953bdda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34f5cab6ec1507f9626c1501b9b8d42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac34f5cab6ec1507f9626c1501b9b8d42">FB_ERROR_IO</a>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:ac34f5cab6ec1507f9626c1501b9b8d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unspecified I/O error occured.  <a href="#ac34f5cab6ec1507f9626c1501b9b8d42">More...</a><br /></td></tr>
<tr class="separator:ac34f5cab6ec1507f9626c1501b9b8d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11335d44d4833a94788908cc0e019c32"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a11335d44d4833a94788908cc0e019c32">FB_ERROR_NLREAD</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:a11335d44d4833a94788908cc0e019c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">No data is available for reading from the transport layer.  <a href="#a11335d44d4833a94788908cc0e019c32">More...</a><br /></td></tr>
<tr class="separator:a11335d44d4833a94788908cc0e019c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a865a476cfedc1bd762a815a919b3d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a6a865a476cfedc1bd762a815a919b3d6">FB_ERROR_NLWRITE</a>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:a6a865a476cfedc1bd762a815a919b3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attempt to write data to the transport layer failed due to closure of the remote end of the connection.  <a href="#a6a865a476cfedc1bd762a815a919b3d6">More...</a><br /></td></tr>
<tr class="separator:a6a865a476cfedc1bd762a815a919b3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69f7dd9d7d77f5b5a247bdf890f4154"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac69f7dd9d7d77f5b5a247bdf890f4154"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac69f7dd9d7d77f5b5a247bdf890f4154">FB_ERROR_NOELEMENT</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:ac69f7dd9d7d77f5b5a247bdf890f4154"><td class="mdescLeft">&#160;</td><td class="mdescRight">The specified Information Element does not exist in the Information Model. <br /></td></tr>
<tr class="separator:ac69f7dd9d7d77f5b5a247bdf890f4154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ab466e80e9545e35a9adb02b2b977c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67ab466e80e9545e35a9adb02b2b977c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a67ab466e80e9545e35a9adb02b2b977c">FB_ERROR_CONN</a>&#160;&#160;&#160;11</td></tr>
<tr class="memdesc:a67ab466e80e9545e35a9adb02b2b977c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A connection or association could not be established or maintained. <br /></td></tr>
<tr class="separator:a67ab466e80e9545e35a9adb02b2b977c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d583572e660442b964f967d6b4e30c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a85d583572e660442b964f967d6b4e30c">FB_ERROR_NETFLOWV9</a>&#160;&#160;&#160;12</td></tr>
<tr class="memdesc:a85d583572e660442b964f967d6b4e30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Illegal NetflowV9 content on a read.  <a href="#a85d583572e660442b964f967d6b4e30c">More...</a><br /></td></tr>
<tr class="separator:a85d583572e660442b964f967d6b4e30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8196a90e2171e3bf24815f96e736eac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8196a90e2171e3bf24815f96e736eac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af8196a90e2171e3bf24815f96e736eac">FB_ERROR_TRANSMISC</a>&#160;&#160;&#160;13</td></tr>
<tr class="memdesc:af8196a90e2171e3bf24815f96e736eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Miscellaneous error occured during translator operation. <br /></td></tr>
<tr class="separator:af8196a90e2171e3bf24815f96e736eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1674866f25bed9de910e6ace8ed9d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd1674866f25bed9de910e6ace8ed9d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#acd1674866f25bed9de910e6ace8ed9d1">FB_ERROR_SFLOW</a>&#160;&#160;&#160;14</td></tr>
<tr class="memdesc:acd1674866f25bed9de910e6ace8ed9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Illegal sFlow content on a read. <br /></td></tr>
<tr class="separator:acd1674866f25bed9de910e6ace8ed9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ed1f6bc4a3e7af62954d03f5131414"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47ed1f6bc4a3e7af62954d03f5131414"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a47ed1f6bc4a3e7af62954d03f5131414">FB_ERROR_SETUP</a>&#160;&#160;&#160;15</td></tr>
<tr class="memdesc:a47ed1f6bc4a3e7af62954d03f5131414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup error. <br /></td></tr>
<tr class="separator:a47ed1f6bc4a3e7af62954d03f5131414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36983de4e17c281e44582a418d5477d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac36983de4e17c281e44582a418d5477d">FB_IE_INIT_FULL</a>(_name_,  _ent_,  _num_,  _len_,  _flags_,  _min_,  _max_,  _type_,  _desc_)&#160;&#160;&#160;{ {(const struct <a class="el" href="structfb_info_element__st.html">fbInfoElement_st</a>*)_name_}, 0, _ent_, _num_, _len_, _flags_, _min_, _max_, _type_, _desc_ }</td></tr>
<tr class="memdesc:ac36983de4e17c281e44582a418d5477d"><td class="mdescLeft">&#160;</td><td class="mdescRight">NEW Convenience macro for creating full fbInfoElement_t static initializers.  <a href="#ac36983de4e17c281e44582a418d5477d">More...</a><br /></td></tr>
<tr class="separator:ac36983de4e17c281e44582a418d5477d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98543cbda640dfca398c2d077382a36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af98543cbda640dfca398c2d077382a36">FB_IE_INIT</a>(_name_,  _ent_,  _num_,  _len_,  _flags_)&#160;&#160;&#160;<a class="el" href="public_8h.html#ac36983de4e17c281e44582a418d5477d">FB_IE_INIT_FULL</a>(_name_, _ent_, _num_, _len_, _flags_, 0, 0, 0, (char*)NULL)</td></tr>
<tr class="memdesc:af98543cbda640dfca398c2d077382a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for creating default fbInfoElement_t static initializers.  <a href="#af98543cbda640dfca398c2d077382a36">More...</a><br /></td></tr>
<tr class="separator:af98543cbda640dfca398c2d077382a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc5e825d2eacc9b5f4df103e4bbf1b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fc5e825d2eacc9b5f4df103e4bbf1b3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a9fc5e825d2eacc9b5f4df103e4bbf1b3">FB_IE_NULL</a>&#160;&#160;&#160;<a class="el" href="public_8h.html#af98543cbda640dfca398c2d077382a36">FB_IE_INIT</a>(NULL, 0, 0, 0, 0)</td></tr>
<tr class="memdesc:a9fc5e825d2eacc9b5f4df103e4bbf1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro defining a null information element initializer to terminate a constant information element array for passing to <a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179" title="Add multiple information elements in an array to an information model. ">fbInfoModelAddElementArray()</a>. <br /></td></tr>
<tr class="separator:a9fc5e825d2eacc9b5f4df103e4bbf1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82de271da22fdfa0bc545bc7fb124d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac82de271da22fdfa0bc545bc7fb124d2">FB_IE_SEMANTIC</a>(flags)&#160;&#160;&#160;((flags &amp; 0x0000ff00) &gt;&gt; 8)</td></tr>
<tr class="memdesc:ac82de271da22fdfa0bc545bc7fb124d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for extracting the information element semantic value from the flags variable in the fbInfoElement_t struct.  <a href="#ac82de271da22fdfa0bc545bc7fb124d2">More...</a><br /></td></tr>
<tr class="separator:ac82de271da22fdfa0bc545bc7fb124d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9613bc9aa4e85dc7f55d990a0e502be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ad9613bc9aa4e85dc7f55d990a0e502be">FB_IE_UNITS</a>(flags)&#160;&#160;&#160;((flags &amp; 0xFFFF0000) &gt;&gt; 16)</td></tr>
<tr class="memdesc:ad9613bc9aa4e85dc7f55d990a0e502be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for extracting the information element units value from the flags variable in the fbInfoElement_t struct.  <a href="#ad9613bc9aa4e85dc7f55d990a0e502be">More...</a><br /></td></tr>
<tr class="separator:ad9613bc9aa4e85dc7f55d990a0e502be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b7a85944a72f6a16741191eb9458df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a57b7a85944a72f6a16741191eb9458df">FB_IE_F_NONE</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="memdesc:a57b7a85944a72f6a16741191eb9458df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default treatment flags value.  <a href="#a57b7a85944a72f6a16741191eb9458df">More...</a><br /></td></tr>
<tr class="separator:a57b7a85944a72f6a16741191eb9458df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8999778f3785deb0579e458b87671832"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8999778f3785deb0579e458b87671832">FB_IE_F_ENDIAN</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="memdesc:a8999778f3785deb0579e458b87671832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information element endian conversion flag.  <a href="#a8999778f3785deb0579e458b87671832">More...</a><br /></td></tr>
<tr class="separator:a8999778f3785deb0579e458b87671832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e002cfbd82eff68afc556f9786c182"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af8e002cfbd82eff68afc556f9786c182">FB_IE_F_REVERSIBLE</a>&#160;&#160;&#160;0x00000040</td></tr>
<tr class="memdesc:af8e002cfbd82eff68afc556f9786c182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information element reversible flag.  <a href="#af8e002cfbd82eff68afc556f9786c182">More...</a><br /></td></tr>
<tr class="separator:af8e002cfbd82eff68afc556f9786c182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5904eae4a46ffa0d02fe24e25bf8f88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ad5904eae4a46ffa0d02fe24e25bf8f88">FB_IE_F_ALIEN</a>&#160;&#160;&#160;0x00000080</td></tr>
<tr class="memdesc:ad5904eae4a46ffa0d02fe24e25bf8f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information element alien flag.  <a href="#ad5904eae4a46ffa0d02fe24e25bf8f88">More...</a><br /></td></tr>
<tr class="separator:ad5904eae4a46ffa0d02fe24e25bf8f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c970f2e2b231ea157c9447e4c84667"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0c970f2e2b231ea157c9447e4c84667"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa0c970f2e2b231ea157c9447e4c84667">FB_IE_QUANTITY</a>&#160;&#160;&#160;0x00000100</td></tr>
<tr class="memdesc:aa0c970f2e2b231ea157c9447e4c84667"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Semantics Flags used to describe an information element as a quantity. <br /></td></tr>
<tr class="separator:aa0c970f2e2b231ea157c9447e4c84667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb0bc5045554f19360ea91ba4a79d77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebb0bc5045554f19360ea91ba4a79d77"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aebb0bc5045554f19360ea91ba4a79d77">FB_IE_TOTALCOUNTER</a>&#160;&#160;&#160;0x00000200</td></tr>
<tr class="memdesc:aebb0bc5045554f19360ea91ba4a79d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Semantics Flags used to describe an information element as a totalCounter. <br /></td></tr>
<tr class="separator:aebb0bc5045554f19360ea91ba4a79d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000256169a355474f096c3193a6ebc6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a000256169a355474f096c3193a6ebc6f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a000256169a355474f096c3193a6ebc6f">FB_IE_DELTACOUNTER</a>&#160;&#160;&#160;0x00000300</td></tr>
<tr class="memdesc:a000256169a355474f096c3193a6ebc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Semantics Flag used to describe an information element as a deltaCounter. <br /></td></tr>
<tr class="separator:a000256169a355474f096c3193a6ebc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301a8ab6a2295910b672021ced2cdb79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a301a8ab6a2295910b672021ced2cdb79"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a301a8ab6a2295910b672021ced2cdb79">FB_IE_IDENTIFIER</a>&#160;&#160;&#160;0x00000400</td></tr>
<tr class="memdesc:a301a8ab6a2295910b672021ced2cdb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Semantics Flag used to describe an information element as an identifier. <br /></td></tr>
<tr class="separator:a301a8ab6a2295910b672021ced2cdb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db17a549651071924517dbd90c99c5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0db17a549651071924517dbd90c99c5a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a0db17a549651071924517dbd90c99c5a">FB_IE_FLAGS</a>&#160;&#160;&#160;0x00000500</td></tr>
<tr class="memdesc:a0db17a549651071924517dbd90c99c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Semantics Flag used to describe an information element as a flags element. <br /></td></tr>
<tr class="separator:a0db17a549651071924517dbd90c99c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7e8a1b24e7faf15058097812edca0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf7e8a1b24e7faf15058097812edca0f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#acf7e8a1b24e7faf15058097812edca0f">FB_IE_LIST</a>&#160;&#160;&#160;0x00000600</td></tr>
<tr class="memdesc:acf7e8a1b24e7faf15058097812edca0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Semantics Flag used to describe an information element as a List Element. <br /></td></tr>
<tr class="separator:acf7e8a1b24e7faf15058097812edca0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb30ac367a08e6b930cb1638ec8b1bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bb30ac367a08e6b930cb1638ec8b1bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a2bb30ac367a08e6b930cb1638ec8b1bc">FB_IE_DEFAULT</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="memdesc:a2bb30ac367a08e6b930cb1638ec8b1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Semantics Flag used to describe an information element as a Default element. <br /></td></tr>
<tr class="separator:a2bb30ac367a08e6b930cb1638ec8b1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f11fd6c323d4d235927eaaa4d5e9bd2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4f11fd6c323d4d235927eaaa4d5e9bd2">FB_UNITS_BITS</a>&#160;&#160;&#160;0x00010000</td></tr>
<tr class="memdesc:a4f11fd6c323d4d235927eaaa4d5e9bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information Element Units - See RFC 5610.  <a href="#a4f11fd6c323d4d235927eaaa4d5e9bd2">More...</a><br /></td></tr>
<tr class="separator:a4f11fd6c323d4d235927eaaa4d5e9bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ab0d8561439404d24ed7b99ccfb4bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a66ab0d8561439404d24ed7b99ccfb4bb">FB_UNITS_OCTETS</a>&#160;&#160;&#160;0x00020000</td></tr>
<tr class="memdesc:a66ab0d8561439404d24ed7b99ccfb4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Units Flag used to describe the units of an information element.  <a href="#a66ab0d8561439404d24ed7b99ccfb4bb">More...</a><br /></td></tr>
<tr class="separator:a66ab0d8561439404d24ed7b99ccfb4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86da86544a71cb898812cebc1eb2b59f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a86da86544a71cb898812cebc1eb2b59f">FB_UNITS_PACKETS</a>&#160;&#160;&#160;0x00030000</td></tr>
<tr class="memdesc:a86da86544a71cb898812cebc1eb2b59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Units Flag used to describe the units of an information element.  <a href="#a86da86544a71cb898812cebc1eb2b59f">More...</a><br /></td></tr>
<tr class="separator:a86da86544a71cb898812cebc1eb2b59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191d0656006408deefde2642767020d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a191d0656006408deefde2642767020d7">FB_UNITS_FLOWS</a>&#160;&#160;&#160;0x00040000</td></tr>
<tr class="memdesc:a191d0656006408deefde2642767020d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Units Flag used to describe the units of an information element.  <a href="#a191d0656006408deefde2642767020d7">More...</a><br /></td></tr>
<tr class="separator:a191d0656006408deefde2642767020d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e17b48c3f3b1eab3bddf19d4e0ae29"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a98e17b48c3f3b1eab3bddf19d4e0ae29">FB_UNITS_SECONDS</a>&#160;&#160;&#160;0x00050000</td></tr>
<tr class="memdesc:a98e17b48c3f3b1eab3bddf19d4e0ae29"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Units Flag used to describe the units of an information element.  <a href="#a98e17b48c3f3b1eab3bddf19d4e0ae29">More...</a><br /></td></tr>
<tr class="separator:a98e17b48c3f3b1eab3bddf19d4e0ae29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc03b5d75f88b606793a7a1bd466c822"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#adc03b5d75f88b606793a7a1bd466c822">FB_UNITS_MILLISECONDS</a>&#160;&#160;&#160;0x00060000</td></tr>
<tr class="memdesc:adc03b5d75f88b606793a7a1bd466c822"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Units Flag used to describe the units of an information element.  <a href="#adc03b5d75f88b606793a7a1bd466c822">More...</a><br /></td></tr>
<tr class="separator:adc03b5d75f88b606793a7a1bd466c822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba28c96ce6b4e15369c59d22e963668"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#abba28c96ce6b4e15369c59d22e963668">FB_UNITS_MICROSECONDS</a>&#160;&#160;&#160;0x00070000</td></tr>
<tr class="memdesc:abba28c96ce6b4e15369c59d22e963668"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Units Flag used to describe the units of an information element.  <a href="#abba28c96ce6b4e15369c59d22e963668">More...</a><br /></td></tr>
<tr class="separator:abba28c96ce6b4e15369c59d22e963668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f064172432cc14b1f32cf26dc8b454"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a43f064172432cc14b1f32cf26dc8b454">FB_UNITS_NANOSECONDS</a>&#160;&#160;&#160;0x00080000</td></tr>
<tr class="memdesc:a43f064172432cc14b1f32cf26dc8b454"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Units Flag used to describe the units of an information element.  <a href="#a43f064172432cc14b1f32cf26dc8b454">More...</a><br /></td></tr>
<tr class="separator:a43f064172432cc14b1f32cf26dc8b454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a1d68de5e84267080edc3f665e3826"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac1a1d68de5e84267080edc3f665e3826">FB_UNITS_WORDS</a>&#160;&#160;&#160;0x00090000</td></tr>
<tr class="memdesc:ac1a1d68de5e84267080edc3f665e3826"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Units Flag used to describe the units of an information element.  <a href="#ac1a1d68de5e84267080edc3f665e3826">More...</a><br /></td></tr>
<tr class="separator:ac1a1d68de5e84267080edc3f665e3826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1e7fd628f34f5ab51e5b3816e1257d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a1e1e7fd628f34f5ab51e5b3816e1257d">FB_UNITS_MESSAGES</a>&#160;&#160;&#160;0x000A0000</td></tr>
<tr class="memdesc:a1e1e7fd628f34f5ab51e5b3816e1257d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Units Flag used to describe the units of an information element.  <a href="#a1e1e7fd628f34f5ab51e5b3816e1257d">More...</a><br /></td></tr>
<tr class="separator:a1e1e7fd628f34f5ab51e5b3816e1257d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca3ce2320dfb6d69eb1c0c74f181bf6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aaca3ce2320dfb6d69eb1c0c74f181bf6">FB_UNITS_HOPS</a>&#160;&#160;&#160;0x000B0000</td></tr>
<tr class="memdesc:aaca3ce2320dfb6d69eb1c0c74f181bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Units Flag used to describe the units of an information element.  <a href="#aaca3ce2320dfb6d69eb1c0c74f181bf6">More...</a><br /></td></tr>
<tr class="separator:aaca3ce2320dfb6d69eb1c0c74f181bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc601d33669b298c15d98ccf55430ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#addc601d33669b298c15d98ccf55430ad">FB_UNITS_ENTRIES</a>&#160;&#160;&#160;0x000C0000</td></tr>
<tr class="memdesc:addc601d33669b298c15d98ccf55430ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Units Flag used to describe the units of an information element.  <a href="#addc601d33669b298c15d98ccf55430ad">More...</a><br /></td></tr>
<tr class="separator:addc601d33669b298c15d98ccf55430ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714a48e1d8c34d9cd3fbcc447e1f21a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a714a48e1d8c34d9cd3fbcc447e1f21a1">FB_UNITS_FRAMES</a>&#160;&#160;&#160;0x000D0000</td></tr>
<tr class="memdesc:a714a48e1d8c34d9cd3fbcc447e1f21a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Information Element Units Flag used to describe the units of an information element.  <a href="#a714a48e1d8c34d9cd3fbcc447e1f21a1">More...</a><br /></td></tr>
<tr class="separator:a714a48e1d8c34d9cd3fbcc447e1f21a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae155c11f8e5f0a4988170b6997d52489"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae155c11f8e5f0a4988170b6997d52489"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae155c11f8e5f0a4988170b6997d52489">FB_IE_VARLEN</a>&#160;&#160;&#160;65535</td></tr>
<tr class="memdesc:ae155c11f8e5f0a4988170b6997d52489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information element length constant for variable-length IE. <br /></td></tr>
<tr class="separator:ae155c11f8e5f0a4988170b6997d52489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3fb2e06562b2f4677d8d6eb2481859"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade3fb2e06562b2f4677d8d6eb2481859"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ade3fb2e06562b2f4677d8d6eb2481859">FB_IE_BASIC_LIST</a>&#160;&#160;&#160;291</td></tr>
<tr class="memdesc:ade3fb2e06562b2f4677d8d6eb2481859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information element number constant for basic lists This will change upon updates to the specification. <br /></td></tr>
<tr class="separator:ade3fb2e06562b2f4677d8d6eb2481859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf07f5462e2e260f899aac2bbf084f21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf07f5462e2e260f899aac2bbf084f21"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#acf07f5462e2e260f899aac2bbf084f21">FB_IE_SUBTEMPLATE_LIST</a>&#160;&#160;&#160;292</td></tr>
<tr class="memdesc:acf07f5462e2e260f899aac2bbf084f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information element number constant for sub template lists This will change upon updates to the IPFIX lists specification. <br /></td></tr>
<tr class="separator:acf07f5462e2e260f899aac2bbf084f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e63e75e26fa69151549b0e359ca85e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e63e75e26fa69151549b0e359ca85e4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8e63e75e26fa69151549b0e359ca85e4">FB_IE_SUBTEMPLATE_MULTILIST</a>&#160;&#160;&#160;293</td></tr>
<tr class="memdesc:a8e63e75e26fa69151549b0e359ca85e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information element number constant for sub template multi lists This will change upon updates to the IPFIX lists specification. <br /></td></tr>
<tr class="separator:a8e63e75e26fa69151549b0e359ca85e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1799c19a4376b5e94a9f2c46af1af0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4e1799c19a4376b5e94a9f2c46af1af0">FB_IE_PEN_REVERSE</a>&#160;&#160;&#160;29305</td></tr>
<tr class="memdesc:a4e1799c19a4376b5e94a9f2c46af1af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private enterprise number for reverse information elements (see draft-ietf-ipfix-biflow-03 section 6.1).  <a href="#a4e1799c19a4376b5e94a9f2c46af1af0">More...</a><br /></td></tr>
<tr class="separator:a4e1799c19a4376b5e94a9f2c46af1af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0892f774e630526db23f2d4090817c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac0892f774e630526db23f2d4090817c1">FB_IE_VENDOR_BIT_REVERSE</a>&#160;&#160;&#160;0x4000</td></tr>
<tr class="memdesc:ac0892f774e630526db23f2d4090817c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse information element bit for vendor-specific information elements (see draft-ietf-ipfix-biflow-03 section 6.2).  <a href="#ac0892f774e630526db23f2d4090817c1">More...</a><br /></td></tr>
<tr class="separator:ac0892f774e630526db23f2d4090817c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd9f74f0b5de011be4ea84cc265d52c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dd9f74f0b5de011be4ea84cc265d52c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a6dd9f74f0b5de011be4ea84cc265d52c">FB_CISCO_GENERIC</a>&#160;&#160;&#160;9999</td></tr>
<tr class="memdesc:a6dd9f74f0b5de011be4ea84cc265d52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic Information Element ID for undefined Cisco NetFlow v9 Elements. <br /></td></tr>
<tr class="separator:a6dd9f74f0b5de011be4ea84cc265d52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae180698bcf1673599ce689814af51078"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae180698bcf1673599ce689814af51078">FB_CISCO_ASA_EVENT_ID</a>&#160;&#160;&#160;9998</td></tr>
<tr class="memdesc:ae180698bcf1673599ce689814af51078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information Element ID for Cisco NSEL Element NF_F_FW_EVENT often exported by Cisco's ASA Device.  <a href="#ae180698bcf1673599ce689814af51078">More...</a><br /></td></tr>
<tr class="separator:ae180698bcf1673599ce689814af51078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1037623125ccfc4f42a08377f61ee1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a0f1037623125ccfc4f42a08377f61ee1">FB_CISCO_ASA_EVENT_XTRA</a>&#160;&#160;&#160;9997</td></tr>
<tr class="memdesc:a0f1037623125ccfc4f42a08377f61ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information Element ID for Cisco NSEL Element NF_F_FW_EXT_EVENT often exported by Cisco's ASA Device.  <a href="#a0f1037623125ccfc4f42a08377f61ee1">More...</a><br /></td></tr>
<tr class="separator:a0f1037623125ccfc4f42a08377f61ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a306f4cc41ea9e8d7828cd6c8023fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af2a306f4cc41ea9e8d7828cd6c8023fd">FB_IE_REVERSE_STR</a>&#160;&#160;&#160;&quot;reverse&quot;</td></tr>
<tr class="memdesc:af2a306f4cc41ea9e8d7828cd6c8023fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse information element name prefix.  <a href="#af2a306f4cc41ea9e8d7828cd6c8023fd">More...</a><br /></td></tr>
<tr class="separator:af2a306f4cc41ea9e8d7828cd6c8023fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac784ef024c2089ce88fe18db93cea70e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac784ef024c2089ce88fe18db93cea70e">FB_IE_REVERSE_STRLEN</a>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:ac784ef024c2089ce88fe18db93cea70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of reverse information element name prefix.  <a href="#ac784ef024c2089ce88fe18db93cea70e">More...</a><br /></td></tr>
<tr class="separator:ac784ef024c2089ce88fe18db93cea70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243165c146a8fbda7e0902a06abce6a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a243165c146a8fbda7e0902a06abce6a4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a243165c146a8fbda7e0902a06abce6a4">FB_TID_AUTO</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a243165c146a8fbda7e0902a06abce6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template ID argument to pass to fbSessionAddTemplate to automatically assign a template ID. <br /></td></tr>
<tr class="separator:a243165c146a8fbda7e0902a06abce6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6666b4a09d3125f8a81364f1918db416"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6666b4a09d3125f8a81364f1918db416"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a6666b4a09d3125f8a81364f1918db416">FB_TID_TS</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a6666b4a09d3125f8a81364f1918db416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserved set ID for template sets. <br /></td></tr>
<tr class="separator:a6666b4a09d3125f8a81364f1918db416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7738504f6d339b29d5d071b1187d65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b7738504f6d339b29d5d071b1187d65"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a6b7738504f6d339b29d5d071b1187d65">FB_TID_OTS</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a6b7738504f6d339b29d5d071b1187d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserved set ID for options template sets. <br /></td></tr>
<tr class="separator:a6b7738504f6d339b29d5d071b1187d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36d9ce926d8c708423062115e429dca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae36d9ce926d8c708423062115e429dca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae36d9ce926d8c708423062115e429dca">FB_TID_MIN_DATA</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:ae36d9ce926d8c708423062115e429dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum non-reserved template ID available for data sets. <br /></td></tr>
<tr class="separator:ae36d9ce926d8c708423062115e429dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f1800b8e6f3d6461798f9c9c6127a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7f1800b8e6f3d6461798f9c9c6127a1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae7f1800b8e6f3d6461798f9c9c6127a1">FB_IESPEC_NULL</a>&#160;&#160;&#160;{ NULL, 0, 0 }</td></tr>
<tr class="memdesc:ae7f1800b8e6f3d6461798f9c9c6127a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro defining a null information element specification initializer to terminate a constant information element specifier array for passing to <a class="el" href="public_8h.html#acb8f6399ecdbbc6af8fbacedc4e49a6c" title="Append information elements described by a specifier array to a template. ">fbTemplateAppendSpecArray()</a>. <br /></td></tr>
<tr class="separator:ae7f1800b8e6f3d6461798f9c9c6127a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6b39310e0db0215096369ffaf342e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4f6b39310e0db0215096369ffaf342e6">FB_CONNSPEC_INIT</a></td></tr>
<tr class="memdesc:a4f6b39310e0db0215096369ffaf342e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro defining a null static fbConnSpec_t.  <a href="#a4f6b39310e0db0215096369ffaf342e6">More...</a><br /></td></tr>
<tr class="separator:a4f6b39310e0db0215096369ffaf342e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f581cd8c25363d1e8bec0effec73aa4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7f581cd8c25363d1e8bec0effec73aa4">FB_LIST_SEM_UNDEFINED</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:a7f581cd8c25363d1e8bec0effec73aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following Semantic values are for use in the structured Data Types: basicLists, subTemplateLists, and subTemplateMultiLists.  <a href="#a7f581cd8c25363d1e8bec0effec73aa4">More...</a><br /></td></tr>
<tr class="separator:a7f581cd8c25363d1e8bec0effec73aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab840e9dca589258104cc19d827c64090"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab840e9dca589258104cc19d827c64090"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ab840e9dca589258104cc19d827c64090">FB_LIST_SEM_NONE_OF</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:ab840e9dca589258104cc19d827c64090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semantic field for none-of value defined in RFC 6313. <br /></td></tr>
<tr class="separator:ab840e9dca589258104cc19d827c64090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7ef124c1f485f2800713d496534908"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac7ef124c1f485f2800713d496534908"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aac7ef124c1f485f2800713d496534908">FB_LIST_SEM_EXACTLY_ONE_OF</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:aac7ef124c1f485f2800713d496534908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semantic field for exactly-one-of value defined in RFC 6313. <br /></td></tr>
<tr class="separator:aac7ef124c1f485f2800713d496534908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62208b656f18793a1aa94b2d3d4a3727"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62208b656f18793a1aa94b2d3d4a3727"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a62208b656f18793a1aa94b2d3d4a3727">FB_LIST_SEM_ONE_OR_MORE_OF</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:a62208b656f18793a1aa94b2d3d4a3727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semantic field for the one-or-more-of value defined in RFC 6313. <br /></td></tr>
<tr class="separator:a62208b656f18793a1aa94b2d3d4a3727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a759ddfdb2b0f8fa409bbc93ceb4fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48a759ddfdb2b0f8fa409bbc93ceb4fb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a48a759ddfdb2b0f8fa409bbc93ceb4fb">FB_LIST_SEM_ALL_OF</a>&#160;&#160;&#160;0x03</td></tr>
<tr class="memdesc:a48a759ddfdb2b0f8fa409bbc93ceb4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semantic field for the all-of value defined in RFC 6313. <br /></td></tr>
<tr class="separator:a48a759ddfdb2b0f8fa409bbc93ceb4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49f4ed8e0a95d29b3a75064a42f95fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa49f4ed8e0a95d29b3a75064a42f95fa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa49f4ed8e0a95d29b3a75064a42f95fa">FB_LIST_SEM_ORDERED</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:aa49f4ed8e0a95d29b3a75064a42f95fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semantic field for the ordered value defined in RFC 6313. <br /></td></tr>
<tr class="separator:aa49f4ed8e0a95d29b3a75064a42f95fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab1479ebe89aecd202bb628c33102129b"><td class="memItemLeft" align="right" valign="top">typedef struct fBuf_st&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a></td></tr>
<tr class="memdesc:ab1479ebe89aecd202bb628c33102129b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An IPFIX message buffer.  <a href="#ab1479ebe89aecd202bb628c33102129b">More...</a><br /></td></tr>
<tr class="separator:ab1479ebe89aecd202bb628c33102129b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c56b8891012ac69488b0a9558aaf9e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfb_varfield__st.html">fbVarfield_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae4c56b8891012ac69488b0a9558aaf9e">fbVarfield_t</a></td></tr>
<tr class="memdesc:ae4c56b8891012ac69488b0a9558aaf9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable-length field value.  <a href="#ae4c56b8891012ac69488b0a9558aaf9e">More...</a><br /></td></tr>
<tr class="separator:ae4c56b8891012ac69488b0a9558aaf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7403b5635628fcc24eeb03b73c0b08bd"><td class="memItemLeft" align="right" valign="top">typedef struct fbInfoModel_st&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a></td></tr>
<tr class="memdesc:a7403b5635628fcc24eeb03b73c0b08bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">An IPFIX information model.  <a href="#a7403b5635628fcc24eeb03b73c0b08bd">More...</a><br /></td></tr>
<tr class="separator:a7403b5635628fcc24eeb03b73c0b08bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab266edf655a9f76181c56257a79f2a9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab266edf655a9f76181c56257a79f2a9a"></a>
typedef struct <a class="el" href="structfb_info_model_iter__st.html">fbInfoModelIter_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ab266edf655a9f76181c56257a79f2a9a">fbInfoModelIter_t</a></td></tr>
<tr class="memdesc:ab266edf655a9f76181c56257a79f2a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over the information elements in an information model. <br /></td></tr>
<tr class="separator:ab266edf655a9f76181c56257a79f2a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3be1d3202f13df9b9439fb76370e1ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3be1d3202f13df9b9439fb76370e1ea"></a>
typedef enum <a class="el" href="public_8h.html#a55a8938c1c2578eb8d5c8ba51612dc1a">fbInfoElementDataType_en</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac3be1d3202f13df9b9439fb76370e1ea">fbInfoElementDataType_t</a></td></tr>
<tr class="memdesc:ac3be1d3202f13df9b9439fb76370e1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">From RFC 5610: A description of the abstract data type of an IPFIX information element as registered in the IANA IPFIX IE Data Type subregistry. <br /></td></tr>
<tr class="separator:ac3be1d3202f13df9b9439fb76370e1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5e041c0ef22a30e1b916c6284cb180"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfb_info_element__st.html">fbInfoElement_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a></td></tr>
<tr class="memdesc:a8e5e041c0ef22a30e1b916c6284cb180"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single IPFIX Information Element definition.  <a href="#a8e5e041c0ef22a30e1b916c6284cb180">More...</a><br /></td></tr>
<tr class="separator:a8e5e041c0ef22a30e1b916c6284cb180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a7ed46d38bf13d31c90dbea49b97c3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfb_info_element_opt_rec__st.html">fbInfoElementOptRec_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a77a7ed46d38bf13d31c90dbea49b97c3">fbInfoElementOptRec_t</a></td></tr>
<tr class="memdesc:a77a7ed46d38bf13d31c90dbea49b97c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corresponding struct to the Information Element Type Options Template.  <a href="#a77a7ed46d38bf13d31c90dbea49b97c3">More...</a><br /></td></tr>
<tr class="separator:a77a7ed46d38bf13d31c90dbea49b97c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a98b02ac2e3547d96e839174270af99"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfb_template__st.html">fbTemplate_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a></td></tr>
<tr class="memdesc:a1a98b02ac2e3547d96e839174270af99"><td class="mdescLeft">&#160;</td><td class="mdescRight">An IPFIX Template or Options Template.  <a href="#a1a98b02ac2e3547d96e839174270af99">More...</a><br /></td></tr>
<tr class="separator:a1a98b02ac2e3547d96e839174270af99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31a6d6f2d24c483d1dc3d7cc8f71009"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfb_info_element_spec__st.html">fbInfoElementSpec_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ab31a6d6f2d24c483d1dc3d7cc8f71009">fbInfoElementSpec_t</a></td></tr>
<tr class="memdesc:ab31a6d6f2d24c483d1dc3d7cc8f71009"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single IPFIX Information Element specification.  <a href="#ab31a6d6f2d24c483d1dc3d7cc8f71009">More...</a><br /></td></tr>
<tr class="separator:ab31a6d6f2d24c483d1dc3d7cc8f71009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8441ccbdab7eaccc081dae0e3af32855"><td class="memItemLeft" align="right" valign="top">typedef struct fbSession_st&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a></td></tr>
<tr class="memdesc:a8441ccbdab7eaccc081dae0e3af32855"><td class="mdescLeft">&#160;</td><td class="mdescRight">An IPFIX Transport Session state container.  <a href="#a8441ccbdab7eaccc081dae0e3af32855">More...</a><br /></td></tr>
<tr class="separator:a8441ccbdab7eaccc081dae0e3af32855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484fac3d07ebd24f2d165a74973be704"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338">fbTransport_en</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a484fac3d07ebd24f2d165a74973be704">fbTransport_t</a></td></tr>
<tr class="memdesc:a484fac3d07ebd24f2d165a74973be704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transport protocol for connection specifier.  <a href="#a484fac3d07ebd24f2d165a74973be704">More...</a><br /></td></tr>
<tr class="separator:a484fac3d07ebd24f2d165a74973be704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc3c1c84682e0e8d89280fbe828b392"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfb_conn_spec__st.html">fbConnSpec_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#abbc3c1c84682e0e8d89280fbe828b392">fbConnSpec_t</a></td></tr>
<tr class="memdesc:abbc3c1c84682e0e8d89280fbe828b392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connection specifier.  <a href="#abbc3c1c84682e0e8d89280fbe828b392">More...</a><br /></td></tr>
<tr class="separator:abbc3c1c84682e0e8d89280fbe828b392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054d6ae24ecc9fbc2e38e683d8a5481a"><td class="memItemLeft" align="right" valign="top">typedef struct fbExporter_st&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a></td></tr>
<tr class="memdesc:a054d6ae24ecc9fbc2e38e683d8a5481a"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPFIX Exporting Process endpoint.  <a href="#a054d6ae24ecc9fbc2e38e683d8a5481a">More...</a><br /></td></tr>
<tr class="separator:a054d6ae24ecc9fbc2e38e683d8a5481a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe40eb39792bfedc00d221c8c9f7a15"><td class="memItemLeft" align="right" valign="top">typedef struct fbCollector_st&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a></td></tr>
<tr class="memdesc:adbe40eb39792bfedc00d221c8c9f7a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPFIX Collecting Process endpoint.  <a href="#adbe40eb39792bfedc00d221c8c9f7a15">More...</a><br /></td></tr>
<tr class="separator:adbe40eb39792bfedc00d221c8c9f7a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4265eb950b491c405d075f1510a5710e"><td class="memItemLeft" align="right" valign="top">typedef struct fbListener_st&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a></td></tr>
<tr class="memdesc:a4265eb950b491c405d075f1510a5710e"><td class="mdescLeft">&#160;</td><td class="mdescRight">IPFIX Collecting Process session listener.  <a href="#a4265eb950b491c405d075f1510a5710e">More...</a><br /></td></tr>
<tr class="separator:a4265eb950b491c405d075f1510a5710e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c43c579a9c79c7adc724c223e3d87c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c43c579a9c79c7adc724c223e3d87c3"></a>
typedef struct <a class="el" href="structfb_listener_entry__st.html">fbListenerEntry_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7c43c579a9c79c7adc724c223e3d87c3">fbListenerEntry_t</a></td></tr>
<tr class="memdesc:a7c43c579a9c79c7adc724c223e3d87c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">ListenerGroup and associated data type definitions. <br /></td></tr>
<tr class="separator:a7c43c579a9c79c7adc724c223e3d87c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae51a493368af916fd3bc701cb8e9383"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae51a493368af916fd3bc701cb8e9383"></a>
typedef struct <a class="el" href="structfb_listener_group_result__st.html">fbListenerGroupResult_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aae51a493368af916fd3bc701cb8e9383">fbListenerGroupResult_t</a></td></tr>
<tr class="memdesc:aae51a493368af916fd3bc701cb8e9383"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef for listener group result <br /></td></tr>
<tr class="separator:aae51a493368af916fd3bc701cb8e9383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08258f227730a0c2bba1fffeac382d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa08258f227730a0c2bba1fffeac382d1"></a>
typedef struct fbListenerGroup_st&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa08258f227730a0c2bba1fffeac382d1">fbListenerGroup_t</a></td></tr>
<tr class="memdesc:aa08258f227730a0c2bba1fffeac382d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that holds the listeners that are added to the group. <br /></td></tr>
<tr class="separator:aa08258f227730a0c2bba1fffeac382d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf94d0c3f1d23a5eeb689c9dd3471fa4"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#adf94d0c3f1d23a5eeb689c9dd3471fa4">fbNewTemplateCallback_fn</a>) (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint16_t tid, <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl)</td></tr>
<tr class="memdesc:adf94d0c3f1d23a5eeb689c9dd3471fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callback function to be called when the session receives a new external template from the connected node.  <a href="#adf94d0c3f1d23a5eeb689c9dd3471fa4">More...</a><br /></td></tr>
<tr class="separator:adf94d0c3f1d23a5eeb689c9dd3471fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7953f7d879b2455a59953f1758f3ca7a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7953f7d879b2455a59953f1758f3ca7a">fbTemplateCtxFree_fn</a>) (void *ctx)</td></tr>
<tr class="memdesc:a7953f7d879b2455a59953f1758f3ca7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function that is called when a template is freed.  <a href="#a7953f7d879b2455a59953f1758f3ca7a">More...</a><br /></td></tr>
<tr class="separator:a7953f7d879b2455a59953f1758f3ca7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcd78cd35aa042de120c5bda82d6670"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a5bcd78cd35aa042de120c5bda82d6670">fbTemplateCtxFree2_fn</a>) (void *tmpl_ctx, void *app_ctx)</td></tr>
<tr class="memdesc:a5bcd78cd35aa042de120c5bda82d6670"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function that is called when a template is freed.  <a href="#a5bcd78cd35aa042de120c5bda82d6670">More...</a><br /></td></tr>
<tr class="separator:a5bcd78cd35aa042de120c5bda82d6670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d68321e6b4bd092c974650224119cbe"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a6d68321e6b4bd092c974650224119cbe">fbTemplateCtxCallback_fn</a>) (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint16_t tid, <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, void **ctx, <a class="el" href="public_8h.html#a7953f7d879b2455a59953f1758f3ca7a">fbTemplateCtxFree_fn</a> *fn)</td></tr>
<tr class="memdesc:a6d68321e6b4bd092c974650224119cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function that will be called when the session receives a new external template.  <a href="#a6d68321e6b4bd092c974650224119cbe">More...</a><br /></td></tr>
<tr class="separator:a6d68321e6b4bd092c974650224119cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3227ccbb8c738607f1370f3176c7a05f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a3227ccbb8c738607f1370f3176c7a05f">fbTemplateCtxCallback2_fn</a>) (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint16_t tid, <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, void *app_ctx, void **tmpl_ctx, <a class="el" href="public_8h.html#a5bcd78cd35aa042de120c5bda82d6670">fbTemplateCtxFree2_fn</a> *fn)</td></tr>
<tr class="memdesc:a3227ccbb8c738607f1370f3176c7a05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function that will be called when the session receives a new external template.  <a href="#a3227ccbb8c738607f1370f3176c7a05f">More...</a><br /></td></tr>
<tr class="separator:a3227ccbb8c738607f1370f3176c7a05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda8181e9f5b364e14ed770071eaf7a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adda8181e9f5b364e14ed770071eaf7a7"></a>
typedef struct <a class="el" href="structfb_basic_list__st.html">fbBasicList_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a></td></tr>
<tr class="memdesc:adda8181e9f5b364e14ed770071eaf7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic list element in a template which structure represents a basic list on the internal side, basic lists in an IPFIX Message must be represented by this structure within the application record. <br /></td></tr>
<tr class="separator:adda8181e9f5b364e14ed770071eaf7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb88011d092a7157d3632a6d660294d6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a></td></tr>
<tr class="memdesc:afb88011d092a7157d3632a6d660294d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used to hold information of a sub template list.  <a href="#afb88011d092a7157d3632a6d660294d6">More...</a><br /></td></tr>
<tr class="separator:afb88011d092a7157d3632a6d660294d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c182c97f40c7c8f213e8e090d9057a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a></td></tr>
<tr class="memdesc:a21c182c97f40c7c8f213e8e090d9057a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entries contain the same type of information at SubTemplateLists: template ID and template pointers to describe the data the number of data elements and the data pointer and data length.  <a href="#a21c182c97f40c7c8f213e8e090d9057a">More...</a><br /></td></tr>
<tr class="separator:a21c182c97f40c7c8f213e8e090d9057a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba12b242961090c27f20231ba153fb5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba12b242961090c27f20231ba153fb5b"></a>
typedef struct <a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_st</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a></td></tr>
<tr class="memdesc:aba12b242961090c27f20231ba153fb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multilists just contain the semantic to describe the sub lists, the number of sub lists, and a pointer to the first entry. <br /></td></tr>
<tr class="separator:aba12b242961090c27f20231ba153fb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4313f40737bf2a6ab1db94693119312c"><td class="memItemLeft" align="right" valign="top">typedef gboolean(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4313f40737bf2a6ab1db94693119312c">fbListenerAppInit_fn</a>) (<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener, void **ctx, int fd, struct sockaddr *peer, size_t peerlen, GError **err)</td></tr>
<tr class="memdesc:a4313f40737bf2a6ab1db94693119312c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application context initialization function type for fbListener_t.  <a href="#a4313f40737bf2a6ab1db94693119312c">More...</a><br /></td></tr>
<tr class="separator:a4313f40737bf2a6ab1db94693119312c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301cd8ac20e8e02e05e3b279ff50a7eb"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a301cd8ac20e8e02e05e3b279ff50a7eb">fbListenerAppFree_fn</a>) (void *ctx)</td></tr>
<tr class="memdesc:a301cd8ac20e8e02e05e3b279ff50a7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Application context free function type for fbListener_t.  <a href="#a301cd8ac20e8e02e05e3b279ff50a7eb">More...</a><br /></td></tr>
<tr class="separator:a301cd8ac20e8e02e05e3b279ff50a7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a55a8938c1c2578eb8d5c8ba51612dc1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55a8938c1c2578eb8d5c8ba51612dc1a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a55a8938c1c2578eb8d5c8ba51612dc1a">fbInfoElementDataType_en</a> { <br />
&#160;&#160;<b>FB_OCTET_ARRAY</b>, 
<b>FB_UINT_8</b>, 
<b>FB_UINT_16</b>, 
<b>FB_UINT_32</b>, 
<br />
&#160;&#160;<b>FB_UINT_64</b>, 
<b>FB_INT_8</b>, 
<b>FB_INT_16</b>, 
<b>FB_INT_32</b>, 
<br />
&#160;&#160;<b>FB_INT_64</b>, 
<b>FB_FLOAT_32</b>, 
<b>FB_FLOAT_64</b>, 
<b>FB_BOOL</b>, 
<br />
&#160;&#160;<b>FB_MAC_ADDR</b>, 
<b>FB_STRING</b>, 
<b>FB_DT_SEC</b>, 
<b>FB_DT_MILSEC</b>, 
<br />
&#160;&#160;<b>FB_DT_MICROSEC</b>, 
<b>FB_DT_NANOSEC</b>, 
<b>FB_IP4_ADDR</b>, 
<b>FB_IP6_ADDR</b>, 
<br />
&#160;&#160;<b>FB_BASIC_LIST</b>, 
<b>FB_SUB_TMPL_LIST</b>, 
<b>FB_SUB_TMPL_MULTI_LIST</b>
<br />
 }<tr class="memdesc:a55a8938c1c2578eb8d5c8ba51612dc1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">From RFC 5610: A description of the abstract data type of an IPFIX information element as registered in the IANA IPFIX IE Data Type subregistry. <br /></td></tr>
</td></tr>
<tr class="separator:a55a8938c1c2578eb8d5c8ba51612dc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b75e3dc15f6c6ebb447598eb7d9338"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338">fbTransport_en</a> { <br />
&#160;&#160;<a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338a7e8c8d5180377a3e0c466dd421a5b541">FB_SCTP</a>, 
<a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338a3d0d039b439e58056f0318fc8d40f69e">FB_TCP</a>, 
<a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338a99b2804a276e4d9bb12df356a58249e2">FB_UDP</a>, 
<a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338a0e089a579ef744ed527b20018e0d2fa9">FB_DTLS_SCTP</a>, 
<br />
&#160;&#160;<a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338a26085cf8945b1127fe9aa2671544cac8">FB_TLS_TCP</a>, 
<a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338a1adfe2d456296749abdd84cc5dcbf997">FB_DTLS_UDP</a>
<br />
 }<tr class="memdesc:a42b75e3dc15f6c6ebb447598eb7d9338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transport protocol for connection specifier.  <a href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a42b75e3dc15f6c6ebb447598eb7d9338"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a357399fb037ea9b0b6e0c641a8f40cec"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a357399fb037ea9b0b6e0c641a8f40cec">fbListValidSemantic</a> (uint8_t semantic)</td></tr>
<tr class="memdesc:a357399fb037ea9b0b6e0c641a8f40cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">validates the value of the semantic field,  <a href="#a357399fb037ea9b0b6e0c641a8f40cec">More...</a><br /></td></tr>
<tr class="separator:a357399fb037ea9b0b6e0c641a8f40cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682b8bb11a27e75655696a565e588415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a682b8bb11a27e75655696a565e588415">fbBasicListAlloc</a> (void)</td></tr>
<tr class="memdesc:a682b8bb11a27e75655696a565e588415"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a Basic List Structure  <a href="#a682b8bb11a27e75655696a565e588415">More...</a><br /></td></tr>
<tr class="separator:a682b8bb11a27e75655696a565e588415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a0558ba604ec339fc908594cdfa74f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a97a0558ba604ec339fc908594cdfa74f">fbBasicListInit</a> (<a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *basicListPtr, uint8_t semantic, const <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *infoElement, uint16_t numElements)</td></tr>
<tr class="memdesc:a97a0558ba604ec339fc908594cdfa74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the basic list structure based on the parameters.  <a href="#a97a0558ba604ec339fc908594cdfa74f">More...</a><br /></td></tr>
<tr class="separator:a97a0558ba604ec339fc908594cdfa74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac422bc91621366c71eb467ec4181d360"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac422bc91621366c71eb467ec4181d360">fbBasicListInitWithOwnBuffer</a> (<a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *basicListPtr, uint8_t semantic, const <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *infoElement, uint16_t numElements, uint16_t dataLength, uint8_t *dataPtr)</td></tr>
<tr class="memdesc:ac422bc91621366c71eb467ec4181d360"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this function to initialize the basic list, but it gets the pointer to a buffer and its length allocated independently from these functions This will generally be used by a collector that does not want to free and allocate new buffers for each incoming message  <a href="#ac422bc91621366c71eb467ec4181d360">More...</a><br /></td></tr>
<tr class="separator:ac422bc91621366c71eb467ec4181d360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86efdc19c5c10383737e0de89c97b950"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a86efdc19c5c10383737e0de89c97b950">fbBasicListCollectorInit</a> (<a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *basicListPtr)</td></tr>
<tr class="memdesc:a86efdc19c5c10383737e0de89c97b950"><td class="mdescLeft">&#160;</td><td class="mdescRight">This initializes a basic list structure for collection.  <a href="#a86efdc19c5c10383737e0de89c97b950">More...</a><br /></td></tr>
<tr class="separator:a86efdc19c5c10383737e0de89c97b950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab246e008d0cfe758ae98c3ac1d0342d1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ab246e008d0cfe758ae98c3ac1d0342d1">fbBasicListGetSemantic</a> (<a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *basicListPtr)</td></tr>
<tr class="memdesc:ab246e008d0cfe758ae98c3ac1d0342d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Semantic field for Basic List presumably used in collectors after decoding.  <a href="#ab246e008d0cfe758ae98c3ac1d0342d1">More...</a><br /></td></tr>
<tr class="separator:ab246e008d0cfe758ae98c3ac1d0342d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcc3e9eed3d8ba2178df3212d7e77f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4fcc3e9eed3d8ba2178df3212d7e77f3">fbBasicListSetSemantic</a> (<a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *basicListPtr, uint8_t semantic)</td></tr>
<tr class="memdesc:a4fcc3e9eed3d8ba2178df3212d7e77f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the semantic for describing a basic list generally used in exporters before decoding.  <a href="#a4fcc3e9eed3d8ba2178df3212d7e77f3">More...</a><br /></td></tr>
<tr class="separator:a4fcc3e9eed3d8ba2178df3212d7e77f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7be05a5a0f8e3b16c6ac3bf1f38a982"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa7be05a5a0f8e3b16c6ac3bf1f38a982">fbBasicListGetInfoElement</a> (<a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *basicListPtr)</td></tr>
<tr class="memdesc:aa7be05a5a0f8e3b16c6ac3bf1f38a982"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a pointer to the information element used in the list it is mainly used in collectors to retrieve information.  <a href="#aa7be05a5a0f8e3b16c6ac3bf1f38a982">More...</a><br /></td></tr>
<tr class="separator:aa7be05a5a0f8e3b16c6ac3bf1f38a982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573bcfbfc4697838625af06884466e17"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a573bcfbfc4697838625af06884466e17">fbBasicListGetDataPtr</a> (<a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *basicListPtr)</td></tr>
<tr class="separator:a573bcfbfc4697838625af06884466e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd859fd4bc3dc5974b321f0eee2e720"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#acdd859fd4bc3dc5974b321f0eee2e720">fbBasicListGetIndexedDataPtr</a> (<a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *basicListPtr, uint16_t bl_index)</td></tr>
<tr class="memdesc:acdd859fd4bc3dc5974b321f0eee2e720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function retrieves the index'th element in the list index is 0-based.  <a href="#acdd859fd4bc3dc5974b321f0eee2e720">More...</a><br /></td></tr>
<tr class="separator:acdd859fd4bc3dc5974b321f0eee2e720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cd86fbb92c002a5a29b466c759393e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa5cd86fbb92c002a5a29b466c759393e">fbBasicListGetNextPtr</a> (<a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *basicListPtr, void *currentPtr)</td></tr>
<tr class="memdesc:aa5cd86fbb92c002a5a29b466c759393e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function returns the next element in the list based on the currentPtr.  <a href="#aa5cd86fbb92c002a5a29b466c759393e">More...</a><br /></td></tr>
<tr class="separator:aa5cd86fbb92c002a5a29b466c759393e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2051991d465d885437c30e886bd86c3c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a2051991d465d885437c30e886bd86c3c">fbBasicListRealloc</a> (<a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *basicList, uint16_t newNumElements)</td></tr>
<tr class="memdesc:a2051991d465d885437c30e886bd86c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the current data pointer, allocating a new buffer to accomodate the new number of elements.  <a href="#a2051991d465d885437c30e886bd86c3c">More...</a><br /></td></tr>
<tr class="separator:a2051991d465d885437c30e886bd86c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d84288b9feaa32be492448b794a3697"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4d84288b9feaa32be492448b794a3697">fbBasicListAddNewElements</a> (<a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *basicList, uint16_t numNewElements)</td></tr>
<tr class="memdesc:a4d84288b9feaa32be492448b794a3697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an additional elememnt into the basic list must be called after calling BasicListInit.  <a href="#a4d84288b9feaa32be492448b794a3697">More...</a><br /></td></tr>
<tr class="separator:a4d84288b9feaa32be492448b794a3697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2da02e486b6f9731f33d059cc5d6eca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae2da02e486b6f9731f33d059cc5d6eca">fbBasicListClear</a> (<a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *basicListPtr)</td></tr>
<tr class="memdesc:ae2da02e486b6f9731f33d059cc5d6eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the parameters of the basic list and free the data buffer.  <a href="#ae2da02e486b6f9731f33d059cc5d6eca">More...</a><br /></td></tr>
<tr class="separator:ae2da02e486b6f9731f33d059cc5d6eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d17288918fee8fddd4c1b37fda3d691"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8d17288918fee8fddd4c1b37fda3d691">fbBasicListClearWithoutFree</a> (<a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *basicList)</td></tr>
<tr class="memdesc:a8d17288918fee8fddd4c1b37fda3d691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the parameters of the basic list, but do not free the buffer.  <a href="#a8d17288918fee8fddd4c1b37fda3d691">More...</a><br /></td></tr>
<tr class="separator:a8d17288918fee8fddd4c1b37fda3d691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3712961929af50bc0900c30cbba773"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aef3712961929af50bc0900c30cbba773">fbBasicListFree</a> (<a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *basicListPtr)</td></tr>
<tr class="memdesc:aef3712961929af50bc0900c30cbba773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the basic list, then free the basic list pointer.  <a href="#aef3712961929af50bc0900c30cbba773">More...</a><br /></td></tr>
<tr class="separator:aef3712961929af50bc0900c30cbba773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929f24a1af3566fc5a57d13ba7d520fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a929f24a1af3566fc5a57d13ba7d520fc">fbSubTemplateListAlloc</a> (void)</td></tr>
<tr class="memdesc:a929f24a1af3566fc5a57d13ba7d520fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a subTemplateList_t Based on how subTemplateLists will be used and set up amidst data structures, this function may never be used.  <a href="#a929f24a1af3566fc5a57d13ba7d520fc">More...</a><br /></td></tr>
<tr class="separator:a929f24a1af3566fc5a57d13ba7d520fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499616fc3525e481de877d726d7ada00"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a499616fc3525e481de877d726d7ada00">fbSubTemplateListInit</a> (<a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *sTL, uint8_t semantic, uint16_t tmplID, const <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, uint16_t numElements)</td></tr>
<tr class="memdesc:a499616fc3525e481de877d726d7ada00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a subTemplateList structure and alloc's the dataPtr to get a buffer able to hold numElements in the template This will mainly be used in exporters preparing to encode.  <a href="#a499616fc3525e481de877d726d7ada00">More...</a><br /></td></tr>
<tr class="separator:a499616fc3525e481de877d726d7ada00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af107185a4e7b9bf3ca1c086f3e170831"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af107185a4e7b9bf3ca1c086f3e170831">fbSubTemplateListInitWithOwnBuffer</a> (<a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *subTemplateList, uint8_t semantic, uint16_t tmplID, const <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, uint16_t numElements, uint16_t dataLength, uint8_t *dataPtr)</td></tr>
<tr class="memdesc:af107185a4e7b9bf3ca1c086f3e170831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the subTemplateList but does not allocate a buffer.  <a href="#af107185a4e7b9bf3ca1c086f3e170831">More...</a><br /></td></tr>
<tr class="separator:af107185a4e7b9bf3ca1c086f3e170831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f0c40ed3a5bb9f0da695f098b1d0c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af0f0c40ed3a5bb9f0da695f098b1d0c3">fbSubTemplateListCollectorInit</a> (<a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *STL)</td></tr>
<tr class="memdesc:af0f0c40ed3a5bb9f0da695f098b1d0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a sub template list variable on a collector.  <a href="#af0f0c40ed3a5bb9f0da695f098b1d0c3">More...</a><br /></td></tr>
<tr class="separator:af0f0c40ed3a5bb9f0da695f098b1d0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c7e51169df7680c9db96befde9cd74"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a91c7e51169df7680c9db96befde9cd74">fbSubTemplateListGetDataPtr</a> (const <a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *subTemplateListPtr)</td></tr>
<tr class="memdesc:a91c7e51169df7680c9db96befde9cd74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the buffer that contains the data for the list.  <a href="#a91c7e51169df7680c9db96befde9cd74">More...</a><br /></td></tr>
<tr class="separator:a91c7e51169df7680c9db96befde9cd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc3c1f936517485ba2ed23945273da7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#abcc3c1f936517485ba2ed23945273da7">fbSubTemplateListGetIndexedDataPtr</a> (const <a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *subTemplateListPtr, uint16_t index)</td></tr>
<tr class="memdesc:abcc3c1f936517485ba2ed23945273da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to iterate over the elements in the list by passing in a counter to indicate which element is to be returned.  <a href="#abcc3c1f936517485ba2ed23945273da7">More...</a><br /></td></tr>
<tr class="separator:abcc3c1f936517485ba2ed23945273da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee412c835fa0ee64eb4a7fc67975e69b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aee412c835fa0ee64eb4a7fc67975e69b">fbSubTemplateListGetNextPtr</a> (const <a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *subTemplateListPtr, void *currentPtr)</td></tr>
<tr class="memdesc:aee412c835fa0ee64eb4a7fc67975e69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function also traverses the elements in the list by accepting a pointer to the last element the user accessed, moves it to the next element and returns a pointer to the next element.  <a href="#aee412c835fa0ee64eb4a7fc67975e69b">More...</a><br /></td></tr>
<tr class="separator:aee412c835fa0ee64eb4a7fc67975e69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea90a84a945c348970d6f24694d761a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aea90a84a945c348970d6f24694d761a0">fbSubTemplateListSetSemantic</a> (<a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *subTemplateListPtr, uint8_t semantic)</td></tr>
<tr class="memdesc:aea90a84a945c348970d6f24694d761a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the semantic parameter of a subTemplateList.  <a href="#aea90a84a945c348970d6f24694d761a0">More...</a><br /></td></tr>
<tr class="separator:aea90a84a945c348970d6f24694d761a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f68a07d50e046fde0d1cfb315ca0e7"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af0f68a07d50e046fde0d1cfb315ca0e7">fbSubTemplateListGetSemantic</a> (<a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *subTemplateListPtr)</td></tr>
<tr class="memdesc:af0f68a07d50e046fde0d1cfb315ca0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the semantic value from a sub template list.  <a href="#af0f68a07d50e046fde0d1cfb315ca0e7">More...</a><br /></td></tr>
<tr class="separator:af0f68a07d50e046fde0d1cfb315ca0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63643493a19bce4564676fbf6b0294b9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a63643493a19bce4564676fbf6b0294b9">fbSubTemplateListGetTemplate</a> (<a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *subTemplateListPtr)</td></tr>
<tr class="memdesc:a63643493a19bce4564676fbf6b0294b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the template pointer from the list structure.  <a href="#a63643493a19bce4564676fbf6b0294b9">More...</a><br /></td></tr>
<tr class="separator:a63643493a19bce4564676fbf6b0294b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cd7af13bdc03147832e868ee3a648f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a26cd7af13bdc03147832e868ee3a648f">fbSubTemplateListGetTemplateID</a> (<a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *subTemplateListPtr)</td></tr>
<tr class="memdesc:a26cd7af13bdc03147832e868ee3a648f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the template ID for the template used by the list.  <a href="#a26cd7af13bdc03147832e868ee3a648f">More...</a><br /></td></tr>
<tr class="separator:a26cd7af13bdc03147832e868ee3a648f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c40d213552ca0d27b9c60ce0fbc1383"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a2c40d213552ca0d27b9c60ce0fbc1383">fbSubTemplateListRealloc</a> (<a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *subTemplateList, uint16_t newNumElements)</td></tr>
<tr class="memdesc:a2c40d213552ca0d27b9c60ce0fbc1383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the current data pointer, allocating a new buffer to accomodate the new number of elements.  <a href="#a2c40d213552ca0d27b9c60ce0fbc1383">More...</a><br /></td></tr>
<tr class="separator:a2c40d213552ca0d27b9c60ce0fbc1383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1974da5e6837cdfb2d0a17d7efc338ef"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a1974da5e6837cdfb2d0a17d7efc338ef">fbSubTemplateListAddNewElements</a> (<a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *subTemplateList, uint16_t numNewElements)</td></tr>
<tr class="memdesc:a1974da5e6837cdfb2d0a17d7efc338ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates space for a number of additional element in the sub template list must be called after the list has been <a class="el" href="public_8h.html#a499616fc3525e481de877d726d7ada00" title="Initializes a subTemplateList structure and alloc&#39;s the dataPtr to get a buffer able to hold numEleme...">fbSubTemplateListInit()</a>'d.  <a href="#a1974da5e6837cdfb2d0a17d7efc338ef">More...</a><br /></td></tr>
<tr class="separator:a1974da5e6837cdfb2d0a17d7efc338ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab25ac70317a2b857ef7acea86ae582"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#adab25ac70317a2b857ef7acea86ae582">fbSubTemplateListClear</a> (<a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *subTemplateListPtr)</td></tr>
<tr class="memdesc:adab25ac70317a2b857ef7acea86ae582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a subtemplate list struct, notably freeing the dataPtr and setting it to NULL.  <a href="#adab25ac70317a2b857ef7acea86ae582">More...</a><br /></td></tr>
<tr class="separator:adab25ac70317a2b857ef7acea86ae582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a97dee08969e092dff301ac73766e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ad6a97dee08969e092dff301ac73766e7">fbSubTemplateListClearWithoutFree</a> (<a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *subTemplateListPtr)</td></tr>
<tr class="memdesc:ad6a97dee08969e092dff301ac73766e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the sub template list parameters but does not free the data ptr.  <a href="#ad6a97dee08969e092dff301ac73766e7">More...</a><br /></td></tr>
<tr class="separator:ad6a97dee08969e092dff301ac73766e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa724aa4ec311288e02dfab42cf23c355"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa724aa4ec311288e02dfab42cf23c355">fbSubTemplateListFree</a> (<a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *subTemplateListPtr)</td></tr>
<tr class="memdesc:aa724aa4ec311288e02dfab42cf23c355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees and clears a subTemplateList struct.  <a href="#aa724aa4ec311288e02dfab42cf23c355">More...</a><br /></td></tr>
<tr class="separator:aa724aa4ec311288e02dfab42cf23c355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6ab661518dde72ba22fb8e232aa6d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a0d6ab661518dde72ba22fb8e232aa6d2">fbSubTemplateMultiListAlloc</a> (void)</td></tr>
<tr class="memdesc:a0d6ab661518dde72ba22fb8e232aa6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a subTemplateMultiList_t Based on how subTemplateMultiLists will be used and set up amidst data structures, this function may never be used.  <a href="#a0d6ab661518dde72ba22fb8e232aa6d2">More...</a><br /></td></tr>
<tr class="separator:a0d6ab661518dde72ba22fb8e232aa6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3c58aebb9dcb758be9fa7eef314781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a3d3c58aebb9dcb758be9fa7eef314781">fbSubTemplateMultiListInit</a> (<a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *STML, uint8_t semantic, uint16_t numElements)</td></tr>
<tr class="memdesc:a3d3c58aebb9dcb758be9fa7eef314781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the multi list with semantic, numbers of elements, and allocates memory to store numElements worth of entries.  <a href="#a3d3c58aebb9dcb758be9fa7eef314781">More...</a><br /></td></tr>
<tr class="separator:a3d3c58aebb9dcb758be9fa7eef314781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8185ac0dfdd2535fb338bddbc4948d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4a8185ac0dfdd2535fb338bddbc4948d">fbSubTemplateMultiListSetSemantic</a> (<a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *STML, uint8_t semantic)</td></tr>
<tr class="memdesc:a4a8185ac0dfdd2535fb338bddbc4948d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the semantic field for the multi list.  <a href="#a4a8185ac0dfdd2535fb338bddbc4948d">More...</a><br /></td></tr>
<tr class="separator:a4a8185ac0dfdd2535fb338bddbc4948d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75970c32e64a7799d61fe32be1ad5c7"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af75970c32e64a7799d61fe32be1ad5c7">fbSubTemplateMultiListGetSemantic</a> (<a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *STML)</td></tr>
<tr class="memdesc:af75970c32e64a7799d61fe32be1ad5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the semantic paramter from the multi list.  <a href="#af75970c32e64a7799d61fe32be1ad5c7">More...</a><br /></td></tr>
<tr class="separator:af75970c32e64a7799d61fe32be1ad5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b01b970a85e30ab72701da7059ae57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a32b01b970a85e30ab72701da7059ae57">fbSubTemplateMultiListClear</a> (<a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *STML)</td></tr>
<tr class="memdesc:a32b01b970a85e30ab72701da7059ae57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all of the entries (frees their data pointers), then frees the memory containing the entries.  <a href="#a32b01b970a85e30ab72701da7059ae57">More...</a><br /></td></tr>
<tr class="separator:a32b01b970a85e30ab72701da7059ae57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c4272a3052cbc6d6385d449f258600"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa0c4272a3052cbc6d6385d449f258600">fbSubTemplateMultiListClearEntries</a> (<a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *STML)</td></tr>
<tr class="memdesc:aa0c4272a3052cbc6d6385d449f258600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the memory used by the entries of a sub template multi list NOTE: if any of those entries contain another layer of structures, that second layer must be freed by the user, this function cannot do that.  <a href="#aa0c4272a3052cbc6d6385d449f258600">More...</a><br /></td></tr>
<tr class="separator:aa0c4272a3052cbc6d6385d449f258600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66fd48ac8abd256e4310962aa8c6728"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ab66fd48ac8abd256e4310962aa8c6728">fbSubTemplateMultiListFree</a> (<a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *STML)</td></tr>
<tr class="memdesc:ab66fd48ac8abd256e4310962aa8c6728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the multi list, then frees the memory pointed to by STML.  <a href="#ab66fd48ac8abd256e4310962aa8c6728">More...</a><br /></td></tr>
<tr class="separator:ab66fd48ac8abd256e4310962aa8c6728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbfaabfe3526969d1bb61b6b68699a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8cbfaabfe3526969d1bb61b6b68699a6">fbSubTemplateMultiListRealloc</a> (<a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *STML, uint16_t newNumEntries)</td></tr>
<tr class="memdesc:a8cbfaabfe3526969d1bb61b6b68699a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the entries used by the multi list, then if newNumElements is different than numElements, frees the entries buffer and allocates a new one.  <a href="#a8cbfaabfe3526969d1bb61b6b68699a6">More...</a><br /></td></tr>
<tr class="separator:a8cbfaabfe3526969d1bb61b6b68699a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ea8ee69f101c7d787c8b64bf76c0b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a37ea8ee69f101c7d787c8b64bf76c0b8">fbSubTemplateMultiListAddNewEntries</a> (<a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *STML, uint16_t numNewEntries)</td></tr>
<tr class="memdesc:a37ea8ee69f101c7d787c8b64bf76c0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds entries to the multi list of entries can only be run after the list has been initialized.  <a href="#a37ea8ee69f101c7d787c8b64bf76c0b8">More...</a><br /></td></tr>
<tr class="separator:a37ea8ee69f101c7d787c8b64bf76c0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfe6e3994cd27f0f2c2863cbc9accd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a2dfe6e3994cd27f0f2c2863cbc9accd6">fbSubTemplateMultiListGetFirstEntry</a> (<a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *STML)</td></tr>
<tr class="memdesc:a2dfe6e3994cd27f0f2c2863cbc9accd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the first entry in the multi list.  <a href="#a2dfe6e3994cd27f0f2c2863cbc9accd6">More...</a><br /></td></tr>
<tr class="separator:a2dfe6e3994cd27f0f2c2863cbc9accd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8234b166da13c96cc3e70c9ca1c57ba9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8234b166da13c96cc3e70c9ca1c57ba9">fbSubTemplateMultiListGetIndexedEntry</a> (<a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *STML, uint16_t index)</td></tr>
<tr class="memdesc:a8234b166da13c96cc3e70c9ca1c57ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the entry of a specific index.  <a href="#a8234b166da13c96cc3e70c9ca1c57ba9">More...</a><br /></td></tr>
<tr class="separator:a8234b166da13c96cc3e70c9ca1c57ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e320134f6cbe6bb42cf2ff353b52636"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7e320134f6cbe6bb42cf2ff353b52636">fbSubTemplateMultiListGetNextEntry</a> (<a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *STML, <a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *currentEntry)</td></tr>
<tr class="memdesc:a7e320134f6cbe6bb42cf2ff353b52636"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function also traverses the elements in the list by accepting a pointer to the last element the user accessed, moves it to the next element and returns a pointer to the next element.  <a href="#a7e320134f6cbe6bb42cf2ff353b52636">More...</a><br /></td></tr>
<tr class="separator:a7e320134f6cbe6bb42cf2ff353b52636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d07cd5e507e5ebac4e9ca32c776636"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ab3d07cd5e507e5ebac4e9ca32c776636">fbSubTemplateMultiListEntryInit</a> (<a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *entry, uint16_t tmplID, <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, uint16_t numElements)</td></tr>
<tr class="memdesc:ab3d07cd5e507e5ebac4e9ca32c776636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the multi list entry with the template values, and allocates the memory used by the entry to hold the data.  <a href="#ab3d07cd5e507e5ebac4e9ca32c776636">More...</a><br /></td></tr>
<tr class="separator:ab3d07cd5e507e5ebac4e9ca32c776636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b35725d9ae682581eaba7bb5f1caefb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8b35725d9ae682581eaba7bb5f1caefb">fbSubTemplateMultiListEntryRealloc</a> (<a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *entry, uint16_t newNumElements)</td></tr>
<tr class="memdesc:a8b35725d9ae682581eaba7bb5f1caefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory for the data used by the entry, then allocates a new buffer based on the size of the template and newNumElements.  <a href="#a8b35725d9ae682581eaba7bb5f1caefb">More...</a><br /></td></tr>
<tr class="separator:a8b35725d9ae682581eaba7bb5f1caefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b007ac32c0a91bbceb9e301b0508e6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae3b007ac32c0a91bbceb9e301b0508e6">fbSubTemplateMultiListEntryAddNewElements</a> (<a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *entry, uint16_t numNewElements)</td></tr>
<tr class="memdesc:ae3b007ac32c0a91bbceb9e301b0508e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates space for a number of additional elements in the sub template multi list entry.  <a href="#ae3b007ac32c0a91bbceb9e301b0508e6">More...</a><br /></td></tr>
<tr class="separator:ae3b007ac32c0a91bbceb9e301b0508e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5362c194595441d9b3cf96f1d92a0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aab5362c194595441d9b3cf96f1d92a0d">fbSubTemplateMultiListEntryClear</a> (<a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *entry)</td></tr>
<tr class="memdesc:aab5362c194595441d9b3cf96f1d92a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory pointed to by the data buffer holding the data elements.  <a href="#aab5362c194595441d9b3cf96f1d92a0d">More...</a><br /></td></tr>
<tr class="separator:aab5362c194595441d9b3cf96f1d92a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3325df690ba3bff4cb9b691a5fe307"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#acb3325df690ba3bff4cb9b691a5fe307">fbSubTemplateMultiListEntryGetDataPtr</a> (<a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *entry)</td></tr>
<tr class="memdesc:acb3325df690ba3bff4cb9b691a5fe307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the data pointer for this entry.  <a href="#acb3325df690ba3bff4cb9b691a5fe307">More...</a><br /></td></tr>
<tr class="separator:acb3325df690ba3bff4cb9b691a5fe307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb644017749befbc7337a9839642ad5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a1bb644017749befbc7337a9839642ad5">fbSubTemplateMultiListEntryNextDataPtr</a> (<a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *entry, void *currentPtr)</td></tr>
<tr class="memdesc:a1bb644017749befbc7337a9839642ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function traverses the elements in the entry by accepting a pointer to the last element the user accessed, moves it to the next element and returns a pointer to the next element.  <a href="#a1bb644017749befbc7337a9839642ad5">More...</a><br /></td></tr>
<tr class="separator:a1bb644017749befbc7337a9839642ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1152a67d46b10b2f0a6550506f06d02"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af1152a67d46b10b2f0a6550506f06d02">fbSubTemplateMultiListEntryGetIndexedPtr</a> (<a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *entry, uint16_t index)</td></tr>
<tr class="memdesc:af1152a67d46b10b2f0a6550506f06d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a data element in the entry based on the index.  <a href="#af1152a67d46b10b2f0a6550506f06d02">More...</a><br /></td></tr>
<tr class="separator:af1152a67d46b10b2f0a6550506f06d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27841bb33f91bbf856c49cd1c0ee32d9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a27841bb33f91bbf856c49cd1c0ee32d9">fbSubTemplateMultiListEntryGetTemplate</a> (<a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *entry)</td></tr>
<tr class="memdesc:a27841bb33f91bbf856c49cd1c0ee32d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the template pointer used to structure the data elements.  <a href="#a27841bb33f91bbf856c49cd1c0ee32d9">More...</a><br /></td></tr>
<tr class="separator:a27841bb33f91bbf856c49cd1c0ee32d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c7ce2b006144807f49d6388309d983"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a87c7ce2b006144807f49d6388309d983">fbSubTemplateMultiListEntryGetTemplateID</a> (<a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *entry)</td></tr>
<tr class="memdesc:a87c7ce2b006144807f49d6388309d983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the template ID for the template used to structure the data.  <a href="#a87c7ce2b006144807f49d6388309d983">More...</a><br /></td></tr>
<tr class="separator:a87c7ce2b006144807f49d6388309d983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6611536bb1193747e0098f5497be821f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a6611536bb1193747e0098f5497be821f">fBufListFree</a> (<a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, uint8_t *record)</td></tr>
<tr class="memdesc:a6611536bb1193747e0098f5497be821f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all of the memory that fixbuf allocated during transcode of this record.  <a href="#a6611536bb1193747e0098f5497be821f">More...</a><br /></td></tr>
<tr class="separator:a6611536bb1193747e0098f5497be821f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c450b3579f5a1fa3c862a647eaa704"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#aa08258f227730a0c2bba1fffeac382d1">fbListenerGroup_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a68c450b3579f5a1fa3c862a647eaa704">fbListenerGroupAlloc</a> (void)</td></tr>
<tr class="memdesc:a68c450b3579f5a1fa3c862a647eaa704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns a fbListenerGroup with no entries.  <a href="#a68c450b3579f5a1fa3c862a647eaa704">More...</a><br /></td></tr>
<tr class="separator:a68c450b3579f5a1fa3c862a647eaa704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf69a6f957c617c392c84c7b57e195b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7bf69a6f957c617c392c84c7b57e195b">fbListenerGroupFree</a> (<a class="el" href="public_8h.html#aa08258f227730a0c2bba1fffeac382d1">fbListenerGroup_t</a> *group)</td></tr>
<tr class="memdesc:a7bf69a6f957c617c392c84c7b57e195b"><td class="mdescLeft">&#160;</td><td class="mdescRight">frees a listener group  <a href="#a7bf69a6f957c617c392c84c7b57e195b">More...</a><br /></td></tr>
<tr class="separator:a7bf69a6f957c617c392c84c7b57e195b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5716c8fe63a2f982e32a98eed0e38f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a5b5716c8fe63a2f982e32a98eed0e38f">fbListenerGroupAddListener</a> (<a class="el" href="public_8h.html#aa08258f227730a0c2bba1fffeac382d1">fbListenerGroup_t</a> *group, const <a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener)</td></tr>
<tr class="memdesc:a5b5716c8fe63a2f982e32a98eed0e38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a previously allocated listener to the previously allocated group.  <a href="#a5b5716c8fe63a2f982e32a98eed0e38f">More...</a><br /></td></tr>
<tr class="separator:a5b5716c8fe63a2f982e32a98eed0e38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9f0add5b127eb4f68270f56b65bc97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#acb9f0add5b127eb4f68270f56b65bc97">fbListenerGroupDeleteListener</a> (<a class="el" href="public_8h.html#aa08258f227730a0c2bba1fffeac382d1">fbListenerGroup_t</a> *group, const <a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener)</td></tr>
<tr class="memdesc:acb9f0add5b127eb4f68270f56b65bc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the listener from the group.  <a href="#acb9f0add5b127eb4f68270f56b65bc97">More...</a><br /></td></tr>
<tr class="separator:acb9f0add5b127eb4f68270f56b65bc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d092063e0986f7fab4444fa0f65822"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#aae51a493368af916fd3bc701cb8e9383">fbListenerGroupResult_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a10d092063e0986f7fab4444fa0f65822">fbListenerGroupWait</a> (<a class="el" href="public_8h.html#aa08258f227730a0c2bba1fffeac382d1">fbListenerGroup_t</a> *group, GError **err)</td></tr>
<tr class="memdesc:a10d092063e0986f7fab4444fa0f65822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to fbListenerWait, except that is looks for connections for multiple listeners.  <a href="#a10d092063e0986f7fab4444fa0f65822">More...</a><br /></td></tr>
<tr class="separator:a10d092063e0986f7fab4444fa0f65822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620984c30070a7b3a1da81d1f84d798d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a620984c30070a7b3a1da81d1f84d798d">fbListenerFreeGroupResult</a> (<a class="el" href="public_8h.html#aae51a493368af916fd3bc701cb8e9383">fbListenerGroupResult_t</a> *result)</td></tr>
<tr class="memdesc:a620984c30070a7b3a1da81d1f84d798d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the fbListenerGroupResult_t returned from fbListenerGroupWait.  <a href="#a620984c30070a7b3a1da81d1f84d798d">More...</a><br /></td></tr>
<tr class="separator:a620984c30070a7b3a1da81d1f84d798d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc226a9f5cef7f773fe55817839179d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#abc226a9f5cef7f773fe55817839179d0">fbListenerOwnSocketCollectorTCP</a> (<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener, int sock, GError **err)</td></tr>
<tr class="memdesc:abc226a9f5cef7f773fe55817839179d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an fBuf wrapped around an independently managed socket and a properly created listener for TCP connections.  <a href="#abc226a9f5cef7f773fe55817839179d0">More...</a><br /></td></tr>
<tr class="separator:abc226a9f5cef7f773fe55817839179d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3048c8b45e2d66218eaf97b2c45fdea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a3048c8b45e2d66218eaf97b2c45fdea0">fbListenerOwnSocketCollectorTLS</a> (<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener, int sock, GError **err)</td></tr>
<tr class="memdesc:a3048c8b45e2d66218eaf97b2c45fdea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as fbListenerOwnSocketCollectorTCP but for TLS (not tested)  <a href="#a3048c8b45e2d66218eaf97b2c45fdea0">More...</a><br /></td></tr>
<tr class="separator:a3048c8b45e2d66218eaf97b2c45fdea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa42fa37b56ab10897b0374360d1a401"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aaa42fa37b56ab10897b0374360d1a401">fBufInterruptSocket</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf)</td></tr>
<tr class="memdesc:aaa42fa37b56ab10897b0374360d1a401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupts the select call of a specific collector by way of its fBuf.  <a href="#aaa42fa37b56ab10897b0374360d1a401">More...</a><br /></td></tr>
<tr class="separator:aaa42fa37b56ab10897b0374360d1a401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c6c56234351a793fd513b212bd31b8"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a28c6c56234351a793fd513b212bd31b8">fBufSetInternalTemplate</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, uint16_t int_tid, GError **err)</td></tr>
<tr class="memdesc:a28c6c56234351a793fd513b212bd31b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal template on a buffer to the given template ID.  <a href="#a28c6c56234351a793fd513b212bd31b8">More...</a><br /></td></tr>
<tr class="separator:a28c6c56234351a793fd513b212bd31b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cd20b1eb9a3287f17587888ee2476b"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af6cd20b1eb9a3287f17587888ee2476b">fBufSetExportTemplate</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, uint16_t ext_tid, GError **err)</td></tr>
<tr class="memdesc:af6cd20b1eb9a3287f17587888ee2476b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the external template for export on a buffer to the given template ID.  <a href="#af6cd20b1eb9a3287f17587888ee2476b">More...</a><br /></td></tr>
<tr class="separator:af6cd20b1eb9a3287f17587888ee2476b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661f4cc21e726345d3e22372af33c2d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a661f4cc21e726345d3e22372af33c2d1">fBufSetAutomaticMode</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, gboolean automatic)</td></tr>
<tr class="memdesc:a661f4cc21e726345d3e22372af33c2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the automatic mode flag on a buffer.  <a href="#a661f4cc21e726345d3e22372af33c2d1">More...</a><br /></td></tr>
<tr class="separator:a661f4cc21e726345d3e22372af33c2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eccf26f7c201064a730728e9a5f9bc"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ad4eccf26f7c201064a730728e9a5f9bc">fBufSetAutomaticInsert</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, GError **err)</td></tr>
<tr class="memdesc:ad4eccf26f7c201064a730728e9a5f9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the automatic insert flag on a buffer.  <a href="#ad4eccf26f7c201064a730728e9a5f9bc">More...</a><br /></td></tr>
<tr class="separator:ad4eccf26f7c201064a730728e9a5f9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0181c5c031ec9b081149d16bab6ac5e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a0181c5c031ec9b081149d16bab6ac5e4">fBufGetSession</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf)</td></tr>
<tr class="memdesc:a0181c5c031ec9b081149d16bab6ac5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the session associated with a buffer.  <a href="#a0181c5c031ec9b081149d16bab6ac5e4">More...</a><br /></td></tr>
<tr class="separator:a0181c5c031ec9b081149d16bab6ac5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064ee09c33f86ac3b4e87320c2ae6463"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a064ee09c33f86ac3b4e87320c2ae6463">fBufFree</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf)</td></tr>
<tr class="memdesc:a064ee09c33f86ac3b4e87320c2ae6463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a buffer.  <a href="#a064ee09c33f86ac3b4e87320c2ae6463">More...</a><br /></td></tr>
<tr class="separator:a064ee09c33f86ac3b4e87320c2ae6463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb7c1a2229e3e8c15c04a215c92329b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a2fb7c1a2229e3e8c15c04a215c92329b">fBufAllocForExport</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, <a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *exporter)</td></tr>
<tr class="memdesc:a2fb7c1a2229e3e8c15c04a215c92329b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new buffer for export.  <a href="#a2fb7c1a2229e3e8c15c04a215c92329b">More...</a><br /></td></tr>
<tr class="separator:a2fb7c1a2229e3e8c15c04a215c92329b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1569a4ca87dc52a3bb70082a2f79eb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa1569a4ca87dc52a3bb70082a2f79eb8">fBufGetExporter</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf)</td></tr>
<tr class="memdesc:aa1569a4ca87dc52a3bb70082a2f79eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the exporting process endpoint associated with a buffer.  <a href="#aa1569a4ca87dc52a3bb70082a2f79eb8">More...</a><br /></td></tr>
<tr class="separator:aa1569a4ca87dc52a3bb70082a2f79eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcd8b28b9e9e51c1a0ce342024b86ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#afbcd8b28b9e9e51c1a0ce342024b86ef">fBufSetExporter</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, <a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *exporter)</td></tr>
<tr class="memdesc:afbcd8b28b9e9e51c1a0ce342024b86ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate an exporting process endpoint with a buffer.  <a href="#afbcd8b28b9e9e51c1a0ce342024b86ef">More...</a><br /></td></tr>
<tr class="separator:afbcd8b28b9e9e51c1a0ce342024b86ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3090cf1b7d116077bb9b627d622fb1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aee3090cf1b7d116077bb9b627d622fb1">fBufRemaining</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf)</td></tr>
<tr class="memdesc:aee3090cf1b7d116077bb9b627d622fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the length of the buffer that is remaining after processing.  <a href="#aee3090cf1b7d116077bb9b627d622fb1">More...</a><br /></td></tr>
<tr class="separator:aee3090cf1b7d116077bb9b627d622fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f24bbb227eb0f2fdd444c8754d9642"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a28f24bbb227eb0f2fdd444c8754d9642">fBufSetBuffer</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, uint8_t *buf, size_t buflen)</td></tr>
<tr class="memdesc:a28f24bbb227eb0f2fdd444c8754d9642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a buffer on an fBuf for collection.  <a href="#a28f24bbb227eb0f2fdd444c8754d9642">More...</a><br /></td></tr>
<tr class="separator:a28f24bbb227eb0f2fdd444c8754d9642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fdaa8626ff753c5b617707698c22b6"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6">fBufAppend</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, uint8_t *recbase, size_t recsize, GError **err)</td></tr>
<tr class="memdesc:ad3fdaa8626ff753c5b617707698c22b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a record to a buffer.  <a href="#ad3fdaa8626ff753c5b617707698c22b6">More...</a><br /></td></tr>
<tr class="separator:ad3fdaa8626ff753c5b617707698c22b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3def007c235fd0dccb7a2293b23341e1"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a3def007c235fd0dccb7a2293b23341e1">fBufEmit</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, GError **err)</td></tr>
<tr class="memdesc:a3def007c235fd0dccb7a2293b23341e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the message currently in a buffer using the associated exporting process endpoint.  <a href="#a3def007c235fd0dccb7a2293b23341e1">More...</a><br /></td></tr>
<tr class="separator:a3def007c235fd0dccb7a2293b23341e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8d9e237f95baf75040575af0df2962"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aff8d9e237f95baf75040575af0df2962">fBufSetExportTime</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, uint32_t extime)</td></tr>
<tr class="memdesc:aff8d9e237f95baf75040575af0df2962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the export time on the message currently in a buffer.  <a href="#aff8d9e237f95baf75040575af0df2962">More...</a><br /></td></tr>
<tr class="separator:aff8d9e237f95baf75040575af0df2962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b2a64c7d212e9c3562388b95b993ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a71b2a64c7d212e9c3562388b95b993ab">fBufAllocForCollection</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, <a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector)</td></tr>
<tr class="memdesc:a71b2a64c7d212e9c3562388b95b993ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new buffer for collection.  <a href="#a71b2a64c7d212e9c3562388b95b993ab">More...</a><br /></td></tr>
<tr class="separator:a71b2a64c7d212e9c3562388b95b993ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1557695deee79d0e3d053b2eda559aa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a1557695deee79d0e3d053b2eda559aa8">fBufGetCollector</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf)</td></tr>
<tr class="memdesc:a1557695deee79d0e3d053b2eda559aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the collecting process endpoint associated with a buffer.  <a href="#a1557695deee79d0e3d053b2eda559aa8">More...</a><br /></td></tr>
<tr class="separator:a1557695deee79d0e3d053b2eda559aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae808992140071be1ccbb258ea012efd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae808992140071be1ccbb258ea012efd0">fBufSetCollector</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, <a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector)</td></tr>
<tr class="memdesc:ae808992140071be1ccbb258ea012efd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate an collecting process endpoint with a buffer.  <a href="#ae808992140071be1ccbb258ea012efd0">More...</a><br /></td></tr>
<tr class="separator:ae808992140071be1ccbb258ea012efd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c40f1d55e2d4b29b40eb4c07ce5ee7"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7">fBufNext</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, uint8_t *recbase, size_t *recsize, GError **err)</td></tr>
<tr class="memdesc:a11c40f1d55e2d4b29b40eb4c07ce5ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a record from a buffer.  <a href="#a11c40f1d55e2d4b29b40eb4c07ce5ee7">More...</a><br /></td></tr>
<tr class="separator:a11c40f1d55e2d4b29b40eb4c07ce5ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c89ee8cc9d536e1ceafb371513a6479"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7c89ee8cc9d536e1ceafb371513a6479">fBufNextMessage</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, GError **err)</td></tr>
<tr class="memdesc:a7c89ee8cc9d536e1ceafb371513a6479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a new message into a buffer using the associated collecting process endpoint.  <a href="#a7c89ee8cc9d536e1ceafb371513a6479">More...</a><br /></td></tr>
<tr class="separator:a7c89ee8cc9d536e1ceafb371513a6479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd3a50bb441990a1d9ae7483595578b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a5bd3a50bb441990a1d9ae7483595578b">fBufGetExportTime</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf)</td></tr>
<tr class="memdesc:a5bd3a50bb441990a1d9ae7483595578b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the export time on the message currently in a buffer.  <a href="#a5bd3a50bb441990a1d9ae7483595578b">More...</a><br /></td></tr>
<tr class="separator:a5bd3a50bb441990a1d9ae7483595578b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04878018c9b5d07cf7bae316da654007"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a04878018c9b5d07cf7bae316da654007">fBufGetCollectionTemplate</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, uint16_t *ext_tid)</td></tr>
<tr class="memdesc:a04878018c9b5d07cf7bae316da654007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the external template used to read the last record from the buffer.  <a href="#a04878018c9b5d07cf7bae316da654007">More...</a><br /></td></tr>
<tr class="separator:a04878018c9b5d07cf7bae316da654007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be7af99ed60994dbbcfbc16701a4ace"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a0be7af99ed60994dbbcfbc16701a4ace">fBufNextCollectionTemplate</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, uint16_t *ext_tid, GError **err)</td></tr>
<tr class="memdesc:a0be7af99ed60994dbbcfbc16701a4ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the external template that will be used to read the next record from the buffer.  <a href="#a0be7af99ed60994dbbcfbc16701a4ace">More...</a><br /></td></tr>
<tr class="separator:a0be7af99ed60994dbbcfbc16701a4ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390f707c7decf65060f31c0dba6c2a97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a390f707c7decf65060f31c0dba6c2a97">fbInfoModelAlloc</a> (void)</td></tr>
<tr class="memdesc:a390f707c7decf65060f31c0dba6c2a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new information model.  <a href="#a390f707c7decf65060f31c0dba6c2a97">More...</a><br /></td></tr>
<tr class="separator:a390f707c7decf65060f31c0dba6c2a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860639c9f5bdf973a8c303aa9f513454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a860639c9f5bdf973a8c303aa9f513454">fbInfoModelFree</a> (<a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model)</td></tr>
<tr class="memdesc:a860639c9f5bdf973a8c303aa9f513454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an information model.  <a href="#a860639c9f5bdf973a8c303aa9f513454">More...</a><br /></td></tr>
<tr class="separator:a860639c9f5bdf973a8c303aa9f513454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06a524366afa6827d7e5abb1c33c0d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae06a524366afa6827d7e5abb1c33c0d0">fbInfoModelAddElement</a> (<a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model, <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *ie)</td></tr>
<tr class="memdesc:ae06a524366afa6827d7e5abb1c33c0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a single information element to an information model.  <a href="#ae06a524366afa6827d7e5abb1c33c0d0">More...</a><br /></td></tr>
<tr class="separator:ae06a524366afa6827d7e5abb1c33c0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202bfa2340263229893a38de18670179"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179">fbInfoModelAddElementArray</a> (<a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model, <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *ie)</td></tr>
<tr class="memdesc:a202bfa2340263229893a38de18670179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add multiple information elements in an array to an information model.  <a href="#a202bfa2340263229893a38de18670179">More...</a><br /></td></tr>
<tr class="separator:a202bfa2340263229893a38de18670179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc8b2e255bc36ca22abbb811bf85c20"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a5dc8b2e255bc36ca22abbb811bf85c20">fbInfoModelGetElementByName</a> (<a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model, const char *name)</td></tr>
<tr class="memdesc:a5dc8b2e255bc36ca22abbb811bf85c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the canonical information element within an information model given the information element name.  <a href="#a5dc8b2e255bc36ca22abbb811bf85c20">More...</a><br /></td></tr>
<tr class="separator:a5dc8b2e255bc36ca22abbb811bf85c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507dc0fe44ee38bab3fb2c29917d5d08"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a507dc0fe44ee38bab3fb2c29917d5d08">fbInfoModelGetElementByID</a> (<a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model, uint16_t id, uint32_t ent)</td></tr>
<tr class="memdesc:a507dc0fe44ee38bab3fb2c29917d5d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the canonical information element within an information model given the information element ID and enterprise ID.  <a href="#a507dc0fe44ee38bab3fb2c29917d5d08">More...</a><br /></td></tr>
<tr class="separator:a507dc0fe44ee38bab3fb2c29917d5d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29af7376716e8e222e6ed7404c95a9b3"><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a29af7376716e8e222e6ed7404c95a9b3">fbInfoModelCountElements</a> (const <a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model)</td></tr>
<tr class="memdesc:a29af7376716e8e222e6ed7404c95a9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of information elements in the information model.  <a href="#a29af7376716e8e222e6ed7404c95a9b3">More...</a><br /></td></tr>
<tr class="separator:a29af7376716e8e222e6ed7404c95a9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93870e732f41f5b29e83aca0b8c73195"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a93870e732f41f5b29e83aca0b8c73195">fbInfoModelIterInit</a> (<a class="el" href="public_8h.html#ab266edf655a9f76181c56257a79f2a9a">fbInfoModelIter_t</a> *iter, const <a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model)</td></tr>
<tr class="memdesc:a93870e732f41f5b29e83aca0b8c73195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an information model iterator for iteration.  <a href="#a93870e732f41f5b29e83aca0b8c73195">More...</a><br /></td></tr>
<tr class="separator:a93870e732f41f5b29e83aca0b8c73195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79356cea24654d750f06a8206249f619"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a79356cea24654d750f06a8206249f619">fbInfoModelIterNext</a> (<a class="el" href="public_8h.html#ab266edf655a9f76181c56257a79f2a9a">fbInfoModelIter_t</a> *iter)</td></tr>
<tr class="memdesc:a79356cea24654d750f06a8206249f619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the next information element in the information model.  <a href="#a79356cea24654d750f06a8206249f619">More...</a><br /></td></tr>
<tr class="separator:a79356cea24654d750f06a8206249f619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f275578868dc08d2a3f8524e2cc379"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a11f275578868dc08d2a3f8524e2cc379">fbInfoElementAllocTypeTemplate</a> (<a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model, GError **err)</td></tr>
<tr class="memdesc:a11f275578868dc08d2a3f8524e2cc379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the Options Template that will be used to define Information Element Type Records.  <a href="#a11f275578868dc08d2a3f8524e2cc379">More...</a><br /></td></tr>
<tr class="separator:a11f275578868dc08d2a3f8524e2cc379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa939fd9269e4cf11317aa8ff9fc48224"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa939fd9269e4cf11317aa8ff9fc48224">fbInfoElementWriteOptionsRecord</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, const <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *model_ie, uint16_t tid, GError **err)</td></tr>
<tr class="memdesc:aa939fd9269e4cf11317aa8ff9fc48224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export an options record to the given fbuf with information element type information about the given information element.  <a href="#aa939fd9269e4cf11317aa8ff9fc48224">More...</a><br /></td></tr>
<tr class="separator:aa939fd9269e4cf11317aa8ff9fc48224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7138c3a3d6df65e4b3e0ec8e236f731"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ad7138c3a3d6df65e4b3e0ec8e236f731">fbInfoElementAddOptRecElement</a> (<a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model, <a class="el" href="public_8h.html#a77a7ed46d38bf13d31c90dbea49b97c3">fbInfoElementOptRec_t</a> *rec)</td></tr>
<tr class="memdesc:ad7138c3a3d6df65e4b3e0ec8e236f731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an element that we received via an Options Record to the given info model.  <a href="#ad7138c3a3d6df65e4b3e0ec8e236f731">More...</a><br /></td></tr>
<tr class="separator:ad7138c3a3d6df65e4b3e0ec8e236f731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d881c33cf7b8b52de4877438f73c0e"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a13d881c33cf7b8b52de4877438f73c0e">fbInfoModelTypeInfoRecord</a> (<a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl)</td></tr>
<tr class="memdesc:a13d881c33cf7b8b52de4877438f73c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if the template contains all of the elements the RFC 5610 info element type record should contain.  <a href="#a13d881c33cf7b8b52de4877438f73c0e">More...</a><br /></td></tr>
<tr class="separator:a13d881c33cf7b8b52de4877438f73c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dad36eadf23739de4fe77ae466c0c7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a6dad36eadf23739de4fe77ae466c0c7d">fbTemplateAlloc</a> (<a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model)</td></tr>
<tr class="memdesc:a6dad36eadf23739de4fe77ae466c0c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new empty template.  <a href="#a6dad36eadf23739de4fe77ae466c0c7d">More...</a><br /></td></tr>
<tr class="separator:a6dad36eadf23739de4fe77ae466c0c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ca9d2de7767f09ddcaa50651ff5b7c"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a06ca9d2de7767f09ddcaa50651ff5b7c">fbTemplateAppend</a> (<a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *ex_ie, GError **err)</td></tr>
<tr class="memdesc:a06ca9d2de7767f09ddcaa50651ff5b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an information element to a template.  <a href="#a06ca9d2de7767f09ddcaa50651ff5b7c">More...</a><br /></td></tr>
<tr class="separator:a06ca9d2de7767f09ddcaa50651ff5b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3507ead494bd3957d325565c66660e79"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a3507ead494bd3957d325565c66660e79">fbTemplateAppendSpec</a> (<a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, <a class="el" href="public_8h.html#ab31a6d6f2d24c483d1dc3d7cc8f71009">fbInfoElementSpec_t</a> *spec, uint32_t flags, GError **err)</td></tr>
<tr class="memdesc:a3507ead494bd3957d325565c66660e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an information element described by specifier to a template.  <a href="#a3507ead494bd3957d325565c66660e79">More...</a><br /></td></tr>
<tr class="separator:a3507ead494bd3957d325565c66660e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8f6399ecdbbc6af8fbacedc4e49a6c"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#acb8f6399ecdbbc6af8fbacedc4e49a6c">fbTemplateAppendSpecArray</a> (<a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, <a class="el" href="public_8h.html#ab31a6d6f2d24c483d1dc3d7cc8f71009">fbInfoElementSpec_t</a> *spec, uint32_t flags, GError **err)</td></tr>
<tr class="memdesc:acb8f6399ecdbbc6af8fbacedc4e49a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append information elements described by a specifier array to a template.  <a href="#acb8f6399ecdbbc6af8fbacedc4e49a6c">More...</a><br /></td></tr>
<tr class="separator:acb8f6399ecdbbc6af8fbacedc4e49a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae789e65af95fb99fcab61474288104ce"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae789e65af95fb99fcab61474288104ce">fbTemplateCountElements</a> (<a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl)</td></tr>
<tr class="memdesc:ae789e65af95fb99fcab61474288104ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine number of information elements in a template.  <a href="#ae789e65af95fb99fcab61474288104ce">More...</a><br /></td></tr>
<tr class="separator:ae789e65af95fb99fcab61474288104ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c24d42f54d9f367db257e2d0df9b451"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a9c24d42f54d9f367db257e2d0df9b451">fbTemplateSetOptionsScope</a> (<a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, uint16_t scope_count)</td></tr>
<tr class="memdesc:a9c24d42f54d9f367db257e2d0df9b451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of information elements in a template that are scope.  <a href="#a9c24d42f54d9f367db257e2d0df9b451">More...</a><br /></td></tr>
<tr class="separator:a9c24d42f54d9f367db257e2d0df9b451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363e2261bf5a74d6efe0f64b19602454"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a363e2261bf5a74d6efe0f64b19602454">fbTemplateGetOptionsScope</a> (<a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl)</td></tr>
<tr class="memdesc:a363e2261bf5a74d6efe0f64b19602454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine number of scope information elements in a template.  <a href="#a363e2261bf5a74d6efe0f64b19602454">More...</a><br /></td></tr>
<tr class="separator:a363e2261bf5a74d6efe0f64b19602454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f92cdd32c7b3d3b2cd868169e94df9"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a12f92cdd32c7b3d3b2cd868169e94df9">fbTemplateContainsElement</a> (<a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, const <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *ex_ie)</td></tr>
<tr class="memdesc:a12f92cdd32c7b3d3b2cd868169e94df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a template contains a given information element.  <a href="#a12f92cdd32c7b3d3b2cd868169e94df9">More...</a><br /></td></tr>
<tr class="separator:a12f92cdd32c7b3d3b2cd868169e94df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefdba7c60efb314f90945a4c3871990"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#afefdba7c60efb314f90945a4c3871990">fbTemplateContainsElementByName</a> (<a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, <a class="el" href="public_8h.html#ab31a6d6f2d24c483d1dc3d7cc8f71009">fbInfoElementSpec_t</a> *spec)</td></tr>
<tr class="memdesc:afefdba7c60efb314f90945a4c3871990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a template contains at least one instance of a given information element, specified by name in the template's information model.  <a href="#afefdba7c60efb314f90945a4c3871990">More...</a><br /></td></tr>
<tr class="separator:afefdba7c60efb314f90945a4c3871990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d6b67bc472d0c5d9519705e4762b0b"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a77d6b67bc472d0c5d9519705e4762b0b">fbTemplateContainsAllElementsByName</a> (<a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, <a class="el" href="public_8h.html#ab31a6d6f2d24c483d1dc3d7cc8f71009">fbInfoElementSpec_t</a> *spec)</td></tr>
<tr class="memdesc:a77d6b67bc472d0c5d9519705e4762b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a template contains at least one instance of each information element in a given information element specifier array.  <a href="#a77d6b67bc472d0c5d9519705e4762b0b">More...</a><br /></td></tr>
<tr class="separator:a77d6b67bc472d0c5d9519705e4762b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373baa2368284e89bd58b5f9643b6222"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a373baa2368284e89bd58b5f9643b6222">fbTemplateContainsAllFlaggedElementsByName</a> (<a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, <a class="el" href="public_8h.html#ab31a6d6f2d24c483d1dc3d7cc8f71009">fbInfoElementSpec_t</a> *spec, uint32_t flags)</td></tr>
<tr class="memdesc:a373baa2368284e89bd58b5f9643b6222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a template contains at least one instance of each information element in a given information element specifier array that match the given flags argument.  <a href="#a373baa2368284e89bd58b5f9643b6222">More...</a><br /></td></tr>
<tr class="separator:a373baa2368284e89bd58b5f9643b6222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1404845cf5022ad6449984e9a6fa782"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa1404845cf5022ad6449984e9a6fa782">fbTemplateGetIndexedIE</a> (<a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, uint32_t IEindex)</td></tr>
<tr class="memdesc:aa1404845cf5022ad6449984e9a6fa782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the information element in the template referenced by the index.  <a href="#aa1404845cf5022ad6449984e9a6fa782">More...</a><br /></td></tr>
<tr class="separator:aa1404845cf5022ad6449984e9a6fa782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0876c0ada0d62b708c7e202c18011380"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a0876c0ada0d62b708c7e202c18011380">fbTemplateFreeUnused</a> (<a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl)</td></tr>
<tr class="memdesc:a0876c0ada0d62b708c7e202c18011380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a template if it is not currently in use by any Session.  <a href="#a0876c0ada0d62b708c7e202c18011380">More...</a><br /></td></tr>
<tr class="separator:a0876c0ada0d62b708c7e202c18011380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bc7e39cde4dfacfc8c85f9ace0bb6d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a57bc7e39cde4dfacfc8c85f9ace0bb6d">fbTemplateGetContext</a> (<a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl)</td></tr>
<tr class="memdesc:a57bc7e39cde4dfacfc8c85f9ace0bb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ctx pointer associated with a Template.  <a href="#a57bc7e39cde4dfacfc8c85f9ace0bb6d">More...</a><br /></td></tr>
<tr class="separator:a57bc7e39cde4dfacfc8c85f9ace0bb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1d8a4523d098e625d5330e0d15bd4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ace1d8a4523d098e625d5330e0d15bd4b">fbSessionAlloc</a> (<a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model)</td></tr>
<tr class="memdesc:ace1d8a4523d098e625d5330e0d15bd4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a transport session state container.  <a href="#ace1d8a4523d098e625d5330e0d15bd4b">More...</a><br /></td></tr>
<tr class="separator:ace1d8a4523d098e625d5330e0d15bd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd6170118372b121d5979fe45825b29"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#afcd6170118372b121d5979fe45825b29">fbSessionEnableTypeMetadata</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, gboolean enabled, GError **err)</td></tr>
<tr class="memdesc:afcd6170118372b121d5979fe45825b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a session to export type information for enterprise-specific information elements as options records according to RFC 5610.  <a href="#afcd6170118372b121d5979fe45825b29">More...</a><br /></td></tr>
<tr class="separator:afcd6170118372b121d5979fe45825b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87cc16e551d18c71f3ad30e8df7ea5b"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac87cc16e551d18c71f3ad30e8df7ea5b">fbSessionEnableTemplateMetadata</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, gboolean enabled, GError **err)</td></tr>
<tr class="memdesc:ac87cc16e551d18c71f3ad30e8df7ea5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a session to export template metadata as options records.  <a href="#ac87cc16e551d18c71f3ad30e8df7ea5b">More...</a><br /></td></tr>
<tr class="separator:ac87cc16e551d18c71f3ad30e8df7ea5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818c3ca59f631a80062a8ccc20748c2a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a818c3ca59f631a80062a8ccc20748c2a">fbSessionAddTemplateWithMetadata</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, gboolean internal, uint16_t tid, <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, const char *name, const char *description, GError **err)</td></tr>
<tr class="memdesc:a818c3ca59f631a80062a8ccc20748c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a template to the session with the provided metadata.  <a href="#a818c3ca59f631a80062a8ccc20748c2a">More...</a><br /></td></tr>
<tr class="separator:a818c3ca59f631a80062a8ccc20748c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844df817659eb1768172b5029347c176"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a844df817659eb1768172b5029347c176">fbSessionSetTemplateMetadata</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint16_t tid, const char *name, const char *description, GError **err)</td></tr>
<tr class="memdesc:a844df817659eb1768172b5029347c176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add template metadata for a given template.  <a href="#a844df817659eb1768172b5029347c176">More...</a><br /></td></tr>
<tr class="separator:a844df817659eb1768172b5029347c176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0479b2b509462b038982dc4e6d6edf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a9a0479b2b509462b038982dc4e6d6edf">fbSessionGetInfoModel</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session)</td></tr>
<tr class="memdesc:a9a0479b2b509462b038982dc4e6d6edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">fbSessionGetInfoModel  <a href="#a9a0479b2b509462b038982dc4e6d6edf">More...</a><br /></td></tr>
<tr class="separator:a9a0479b2b509462b038982dc4e6d6edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571e85ca2f6c01b1c94932e546b978e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a571e85ca2f6c01b1c94932e546b978e9">fbSessionAddTemplateCallback</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, <a class="el" href="public_8h.html#adf94d0c3f1d23a5eeb689c9dd3471fa4">fbNewTemplateCallback_fn</a> callback)</td></tr>
<tr class="memdesc:a571e85ca2f6c01b1c94932e546b978e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the callback to let the user know when a new template has arrived from the connected IPFIX node.  <a href="#a571e85ca2f6c01b1c94932e546b978e9">More...</a><br /></td></tr>
<tr class="separator:a571e85ca2f6c01b1c94932e546b978e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e20dba1b69e83a4cbd33da8b1e8bcc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a0e20dba1b69e83a4cbd33da8b1e8bcc6">fbSessionAddTemplateCtxCallback</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, <a class="el" href="public_8h.html#a6d68321e6b4bd092c974650224119cbe">fbTemplateCtxCallback_fn</a> callback)</td></tr>
<tr class="memdesc:a0e20dba1b69e83a4cbd33da8b1e8bcc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the callback that allows the application to set its own context variable with a new incoming template.  <a href="#a0e20dba1b69e83a4cbd33da8b1e8bcc6">More...</a><br /></td></tr>
<tr class="separator:a0e20dba1b69e83a4cbd33da8b1e8bcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd78f8739bd2c5c3984bb0b6959b99ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#abd78f8739bd2c5c3984bb0b6959b99ff">fbSessionAddTemplateCtxCallback2</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, <a class="el" href="public_8h.html#a3227ccbb8c738607f1370f3176c7a05f">fbTemplateCtxCallback2_fn</a> callback, void *app_ctx)</td></tr>
<tr class="memdesc:abd78f8739bd2c5c3984bb0b6959b99ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the callback that allows the application to set its own context variable with a new incoming template.  <a href="#abd78f8739bd2c5c3984bb0b6959b99ff">More...</a><br /></td></tr>
<tr class="separator:abd78f8739bd2c5c3984bb0b6959b99ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b142aa40a63aab16b297c77649f3d5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a1b142aa40a63aab16b297c77649f3d5c">fbSessionAddTemplatePair</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint16_t ent_tid, uint16_t int_tid)</td></tr>
<tr class="memdesc:a1b142aa40a63aab16b297c77649f3d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an external-internal template pair to the session.  <a href="#a1b142aa40a63aab16b297c77649f3d5c">More...</a><br /></td></tr>
<tr class="separator:a1b142aa40a63aab16b297c77649f3d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae285ec588b2c18d3e57ff92ee4090ce5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae285ec588b2c18d3e57ff92ee4090ce5">fbSessionRemoveTemplatePair</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint16_t ext_tid)</td></tr>
<tr class="memdesc:ae285ec588b2c18d3e57ff92ee4090ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove a template pair from the list this is called by fixbuf when a template is revoked from the session by the node on the other end of the connection  <a href="#ae285ec588b2c18d3e57ff92ee4090ce5">More...</a><br /></td></tr>
<tr class="separator:ae285ec588b2c18d3e57ff92ee4090ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d63552a3f19493ec9e05c6826f3a6ed"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7d63552a3f19493ec9e05c6826f3a6ed">fbSessionLookupTemplatePair</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint16_t ext_tid)</td></tr>
<tr class="memdesc:a7d63552a3f19493ec9e05c6826f3a6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find a pair, uniquely identified by the external ID, and return the associated internal template ID.  <a href="#a7d63552a3f19493ec9e05c6826f3a6ed">More...</a><br /></td></tr>
<tr class="separator:a7d63552a3f19493ec9e05c6826f3a6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6672c72da8b767025ff9bd5bb54a82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4d6672c72da8b767025ff9bd5bb54a82">fbSessionFree</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session)</td></tr>
<tr class="memdesc:a4d6672c72da8b767025ff9bd5bb54a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a transport session state container.  <a href="#a4d6672c72da8b767025ff9bd5bb54a82">More...</a><br /></td></tr>
<tr class="separator:a4d6672c72da8b767025ff9bd5bb54a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ebb73e4655052664d69e9b1876543d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac7ebb73e4655052664d69e9b1876543d">fbSessionResetExternal</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session)</td></tr>
<tr class="memdesc:ac7ebb73e4655052664d69e9b1876543d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the external state (sequence numbers and templates) in a session state container.  <a href="#ac7ebb73e4655052664d69e9b1876543d">More...</a><br /></td></tr>
<tr class="separator:ac7ebb73e4655052664d69e9b1876543d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f2a7b352786c72e05738a5f1d4f293"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a80f2a7b352786c72e05738a5f1d4f293">fbSessionSetDomain</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint32_t domain)</td></tr>
<tr class="memdesc:a80f2a7b352786c72e05738a5f1d4f293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current observation domain on a session.  <a href="#a80f2a7b352786c72e05738a5f1d4f293">More...</a><br /></td></tr>
<tr class="separator:a80f2a7b352786c72e05738a5f1d4f293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4577b6072c238c6d56f08555191ebb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4b4577b6072c238c6d56f08555191ebb">fbSessionGetDomain</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session)</td></tr>
<tr class="memdesc:a4b4577b6072c238c6d56f08555191ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current domain on a session.  <a href="#a4b4577b6072c238c6d56f08555191ebb">More...</a><br /></td></tr>
<tr class="separator:a4b4577b6072c238c6d56f08555191ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516f525385226edde5133332c4920f6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a516f525385226edde5133332c4920f6a">fbSessionGetCollector</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session)</td></tr>
<tr class="memdesc:a516f525385226edde5133332c4920f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve collector that was created with the session.  <a href="#a516f525385226edde5133332c4920f6a">More...</a><br /></td></tr>
<tr class="separator:a516f525385226edde5133332c4920f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9236bdb53a94cd19bad3fef2c9bfb947"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a9236bdb53a94cd19bad3fef2c9bfb947">fbSessionExportTemplate</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint16_t tid, GError **err)</td></tr>
<tr class="memdesc:a9236bdb53a94cd19bad3fef2c9bfb947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export a single external template in the current domain of a given session.  <a href="#a9236bdb53a94cd19bad3fef2c9bfb947">More...</a><br /></td></tr>
<tr class="separator:a9236bdb53a94cd19bad3fef2c9bfb947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0c42fc80985c048190203257697ab6"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4e0c42fc80985c048190203257697ab6">fbSessionExportTemplates</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, GError **err)</td></tr>
<tr class="memdesc:a4e0c42fc80985c048190203257697ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export all external templates in the current domain of a given session.  <a href="#a4e0c42fc80985c048190203257697ab6">More...</a><br /></td></tr>
<tr class="separator:a4e0c42fc80985c048190203257697ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4baf6d2142eca4cb526b1e80628bf8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a2e4baf6d2142eca4cb526b1e80628bf8">fbSessionAddTemplate</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, gboolean internal, uint16_t tid, <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, GError **err)</td></tr>
<tr class="memdesc:a2e4baf6d2142eca4cb526b1e80628bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a template to a session.  <a href="#a2e4baf6d2142eca4cb526b1e80628bf8">More...</a><br /></td></tr>
<tr class="separator:a2e4baf6d2142eca4cb526b1e80628bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26aa6df19f1e9118c957d2b2359021d0"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a26aa6df19f1e9118c957d2b2359021d0">fbSessionRemoveTemplate</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, gboolean internal, uint16_t tid, GError **err)</td></tr>
<tr class="memdesc:a26aa6df19f1e9118c957d2b2359021d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a template from a session.  <a href="#a26aa6df19f1e9118c957d2b2359021d0">More...</a><br /></td></tr>
<tr class="separator:a26aa6df19f1e9118c957d2b2359021d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf0ea7e68b9e58aa3fe8e0fbdc1e713"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a0bf0ea7e68b9e58aa3fe8e0fbdc1e713">fbSessionGetTemplate</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, gboolean internal, uint16_t tid, GError **err)</td></tr>
<tr class="memdesc:a0bf0ea7e68b9e58aa3fe8e0fbdc1e713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a template from a session by ID.  <a href="#a0bf0ea7e68b9e58aa3fe8e0fbdc1e713">More...</a><br /></td></tr>
<tr class="separator:a0bf0ea7e68b9e58aa3fe8e0fbdc1e713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ccd30ae0534e838107d39769b8f9f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a56ccd30ae0534e838107d39769b8f9f9">fbExporterAllocNet</a> (<a class="el" href="public_8h.html#abbc3c1c84682e0e8d89280fbe828b392">fbConnSpec_t</a> *spec)</td></tr>
<tr class="memdesc:a56ccd30ae0534e838107d39769b8f9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an exporting process endpoint for a network connection.  <a href="#a56ccd30ae0534e838107d39769b8f9f9">More...</a><br /></td></tr>
<tr class="separator:a56ccd30ae0534e838107d39769b8f9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b159cd95821b4382a04543f18faa279"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8b159cd95821b4382a04543f18faa279">fbExporterAllocFile</a> (const char *path)</td></tr>
<tr class="memdesc:a8b159cd95821b4382a04543f18faa279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an exporting process endpoint for a named file.  <a href="#a8b159cd95821b4382a04543f18faa279">More...</a><br /></td></tr>
<tr class="separator:a8b159cd95821b4382a04543f18faa279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf2759b8c7997a09af6c5b78af43861"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a6cf2759b8c7997a09af6c5b78af43861">fbExporterAllocBuffer</a> (uint8_t *buf, uint16_t bufsize)</td></tr>
<tr class="memdesc:a6cf2759b8c7997a09af6c5b78af43861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an exporting process for a buffer.  <a href="#a6cf2759b8c7997a09af6c5b78af43861">More...</a><br /></td></tr>
<tr class="separator:a6cf2759b8c7997a09af6c5b78af43861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4055c4e29d7358629373e2be2a89a4dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4055c4e29d7358629373e2be2a89a4dd">fbExporterAllocFP</a> (FILE *fp)</td></tr>
<tr class="memdesc:a4055c4e29d7358629373e2be2a89a4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an exporting process endpoint for an opened ANSI C file pointer.  <a href="#a4055c4e29d7358629373e2be2a89a4dd">More...</a><br /></td></tr>
<tr class="separator:a4055c4e29d7358629373e2be2a89a4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7419bcb555dba21cba184f7ce50086"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8d7419bcb555dba21cba184f7ce50086">fbExporterSetStream</a> (<a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *exporter, int sctp_stream)</td></tr>
<tr class="memdesc:a8d7419bcb555dba21cba184f7ce50086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the SCTP stream for the next message exported.  <a href="#a8d7419bcb555dba21cba184f7ce50086">More...</a><br /></td></tr>
<tr class="separator:a8d7419bcb555dba21cba184f7ce50086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809156340bdb9a1003ad57114eef5e0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a809156340bdb9a1003ad57114eef5e0b">fbExporterAutoStream</a> (<a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *exporter)</td></tr>
<tr class="memdesc:a809156340bdb9a1003ad57114eef5e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable automatic SCTP stream selection for the next message exported.  <a href="#a809156340bdb9a1003ad57114eef5e0b">More...</a><br /></td></tr>
<tr class="separator:a809156340bdb9a1003ad57114eef5e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91f3ef3a469b8ec03eb195e70dbc16f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac91f3ef3a469b8ec03eb195e70dbc16f">fbExporterClose</a> (<a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *exporter)</td></tr>
<tr class="memdesc:ac91f3ef3a469b8ec03eb195e70dbc16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the file or socket underlying an exporting process endpoint to close.  <a href="#ac91f3ef3a469b8ec03eb195e70dbc16f">More...</a><br /></td></tr>
<tr class="separator:ac91f3ef3a469b8ec03eb195e70dbc16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d50a75267c63f2a3c12b2118714c16f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a9d50a75267c63f2a3c12b2118714c16f">fbExporterGetMsgLen</a> (<a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *exporter)</td></tr>
<tr class="memdesc:a9d50a75267c63f2a3c12b2118714c16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (transcoded) message length that was copied to the exporting buffer upon <a class="el" href="public_8h.html#a3def007c235fd0dccb7a2293b23341e1" title="Emit the message currently in a buffer using the associated exporting process endpoint. ">fBufEmit()</a>.  <a href="#a9d50a75267c63f2a3c12b2118714c16f">More...</a><br /></td></tr>
<tr class="separator:a9d50a75267c63f2a3c12b2118714c16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7549b8dcc9e44f02187708cfb36d14bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7549b8dcc9e44f02187708cfb36d14bc">fbCollectorAllocFile</a> (void *ctx, const char *path, GError **err)</td></tr>
<tr class="memdesc:a7549b8dcc9e44f02187708cfb36d14bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a collecting process endpoint for a named file.  <a href="#a7549b8dcc9e44f02187708cfb36d14bc">More...</a><br /></td></tr>
<tr class="separator:a7549b8dcc9e44f02187708cfb36d14bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9891f65a4f6d838152b92c7afe97cc8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a9891f65a4f6d838152b92c7afe97cc8d">fbCollectorAllocFP</a> (void *ctx, FILE *fp)</td></tr>
<tr class="memdesc:a9891f65a4f6d838152b92c7afe97cc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a collecting process endpoint for an open file.  <a href="#a9891f65a4f6d838152b92c7afe97cc8d">More...</a><br /></td></tr>
<tr class="separator:a9891f65a4f6d838152b92c7afe97cc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fa506279884348752111ff3bb52882"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ad9fa506279884348752111ff3bb52882">fbCollectorGetContext</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector)</td></tr>
<tr class="memdesc:ad9fa506279884348752111ff3bb52882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the application context associated with a collector.  <a href="#ad9fa506279884348752111ff3bb52882">More...</a><br /></td></tr>
<tr class="separator:ad9fa506279884348752111ff3bb52882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef460934e9c8a4fe3530cf06f66ea3cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aef460934e9c8a4fe3530cf06f66ea3cb">fbCollectorClose</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector)</td></tr>
<tr class="memdesc:aef460934e9c8a4fe3530cf06f66ea3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the file or socket underlying a collecting process endpoint.  <a href="#aef460934e9c8a4fe3530cf06f66ea3cb">More...</a><br /></td></tr>
<tr class="separator:aef460934e9c8a4fe3530cf06f66ea3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39b5a9a1eb9e8c8feaa9922cf73b300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac39b5a9a1eb9e8c8feaa9922cf73b300">fbCollectorSetAcceptOnly</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector, struct sockaddr *address, size_t address_length)</td></tr>
<tr class="memdesc:ac39b5a9a1eb9e8c8feaa9922cf73b300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the collector to only receive from the given IP address over UDP.  <a href="#ac39b5a9a1eb9e8c8feaa9922cf73b300">More...</a><br /></td></tr>
<tr class="separator:ac39b5a9a1eb9e8c8feaa9922cf73b300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a2e34a62fbfe7fe37dffa8b6b05048"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a68a2e34a62fbfe7fe37dffa8b6b05048">fbListenerAlloc</a> (<a class="el" href="public_8h.html#abbc3c1c84682e0e8d89280fbe828b392">fbConnSpec_t</a> *spec, <a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, <a class="el" href="public_8h.html#a4313f40737bf2a6ab1db94693119312c">fbListenerAppInit_fn</a> appinit, <a class="el" href="public_8h.html#a301cd8ac20e8e02e05e3b279ff50a7eb">fbListenerAppFree_fn</a> appfree, GError **err)</td></tr>
<tr class="memdesc:a68a2e34a62fbfe7fe37dffa8b6b05048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a listener.  <a href="#a68a2e34a62fbfe7fe37dffa8b6b05048">More...</a><br /></td></tr>
<tr class="separator:a68a2e34a62fbfe7fe37dffa8b6b05048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb413ad5afd11a0437b583f922eb70a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aceb413ad5afd11a0437b583f922eb70a">fbListenerFree</a> (<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener)</td></tr>
<tr class="memdesc:aceb413ad5afd11a0437b583f922eb70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a listener.  <a href="#aceb413ad5afd11a0437b583f922eb70a">More...</a><br /></td></tr>
<tr class="separator:aceb413ad5afd11a0437b583f922eb70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514187cc62c75d4ed92ae2e497d21a42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42">fbListenerWait</a> (<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener, GError **err)</td></tr>
<tr class="memdesc:a514187cc62c75d4ed92ae2e497d21a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a listener.  <a href="#a514187cc62c75d4ed92ae2e497d21a42">More...</a><br /></td></tr>
<tr class="separator:a514187cc62c75d4ed92ae2e497d21a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0fd5679efb1df055c72cfc10189363"><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a0d0fd5679efb1df055c72cfc10189363">fbListenerWaitNoCollectors</a> (<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener, GError **err)</td></tr>
<tr class="memdesc:a0d0fd5679efb1df055c72cfc10189363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for an incoming connection, just like fbListenerWait, except that this function doesn't monitor active collectors.  <a href="#a0d0fd5679efb1df055c72cfc10189363">More...</a><br /></td></tr>
<tr class="separator:a0d0fd5679efb1df055c72cfc10189363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efdc23863fcb2725c6d29c575fcbaa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7efdc23863fcb2725c6d29c575fcbaa7">fbListenerInterrupt</a> (<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener)</td></tr>
<tr class="memdesc:a7efdc23863fcb2725c6d29c575fcbaa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause the current or next call to fbListenerWait to unblock and return.  <a href="#a7efdc23863fcb2725c6d29c575fcbaa7">More...</a><br /></td></tr>
<tr class="separator:a7efdc23863fcb2725c6d29c575fcbaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e64858b1a8766f7e2889b1de70fca97"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7e64858b1a8766f7e2889b1de70fca97">fbListenerGetCollector</a> (<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener, <a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> **collector, GError **err)</td></tr>
<tr class="memdesc:a7e64858b1a8766f7e2889b1de70fca97"><td class="mdescLeft">&#160;</td><td class="mdescRight">fbListenerGetCollector  <a href="#a7e64858b1a8766f7e2889b1de70fca97">More...</a><br /></td></tr>
<tr class="separator:a7e64858b1a8766f7e2889b1de70fca97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d8b5f0c77c81fb9c67e3509418d724"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a52d8b5f0c77c81fb9c67e3509418d724">fbCollectorClearTranslator</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector, GError **err)</td></tr>
<tr class="memdesc:a52d8b5f0c77c81fb9c67e3509418d724"><td class="mdescLeft">&#160;</td><td class="mdescRight">fbCollectorClearTranslator  <a href="#a52d8b5f0c77c81fb9c67e3509418d724">More...</a><br /></td></tr>
<tr class="separator:a52d8b5f0c77c81fb9c67e3509418d724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa751f591a9ae4cd4a46c57f11798a592"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa751f591a9ae4cd4a46c57f11798a592">fbCollectorSetNetflowV9Translator</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector, GError **err)</td></tr>
<tr class="memdesc:aa751f591a9ae4cd4a46c57f11798a592"><td class="mdescLeft">&#160;</td><td class="mdescRight">fbCollectorSetNetflowV9Translator  <a href="#aa751f591a9ae4cd4a46c57f11798a592">More...</a><br /></td></tr>
<tr class="separator:aa751f591a9ae4cd4a46c57f11798a592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e50cd60e8a848fcd5191da59c2bad0"><td class="memItemLeft" align="right" valign="top">gboolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a91e50cd60e8a848fcd5191da59c2bad0">fbCollectorSetSFlowTranslator</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector, GError **err)</td></tr>
<tr class="memdesc:a91e50cd60e8a848fcd5191da59c2bad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">fbCollectorSetSFlowTranslator  <a href="#a91e50cd60e8a848fcd5191da59c2bad0">More...</a><br /></td></tr>
<tr class="separator:a91e50cd60e8a848fcd5191da59c2bad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cc8db0d961b61a5087c5b107b8c1eb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a09cc8db0d961b61a5087c5b107b8c1eb">fbCollectorGetNetflowMissed</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector, struct sockaddr *peer, size_t peerlen, uint32_t obdomain)</td></tr>
<tr class="memdesc:a09cc8db0d961b61a5087c5b107b8c1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">fbCollectorGetNetflowMissed  <a href="#a09cc8db0d961b61a5087c5b107b8c1eb">More...</a><br /></td></tr>
<tr class="separator:a09cc8db0d961b61a5087c5b107b8c1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d103bec199e48b0ec8a335b4f0cf3c7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a1d103bec199e48b0ec8a335b4f0cf3c7">fbCollectorGetSFlowMissed</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector, struct sockaddr *peer, size_t peerlen, uint32_t obdomain)</td></tr>
<tr class="memdesc:a1d103bec199e48b0ec8a335b4f0cf3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">fbCollectorGetSFlowMissed  <a href="#a1d103bec199e48b0ec8a335b4f0cf3c7">More...</a><br /></td></tr>
<tr class="separator:a1d103bec199e48b0ec8a335b4f0cf3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c920e8f0a74ca9ea1d4a40386d673f"><td class="memItemLeft" align="right" valign="top">struct sockaddr *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a85c920e8f0a74ca9ea1d4a40386d673f">fbCollectorGetPeer</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector)</td></tr>
<tr class="memdesc:a85c920e8f0a74ca9ea1d4a40386d673f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves information about the node connected to this collector.  <a href="#a85c920e8f0a74ca9ea1d4a40386d673f">More...</a><br /></td></tr>
<tr class="separator:a85c920e8f0a74ca9ea1d4a40386d673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68260b0fb1b7947f6a76152a7c4cb6c1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a68260b0fb1b7947f6a76152a7c4cb6c1">fbCollectorGetObservationDomain</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector)</td></tr>
<tr class="memdesc:a68260b0fb1b7947f6a76152a7c4cb6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the observation domain of the node connected to the UDP collector.  <a href="#a68260b0fb1b7947f6a76152a7c4cb6c1">More...</a><br /></td></tr>
<tr class="separator:a68260b0fb1b7947f6a76152a7c4cb6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b18e9e1ccb41a90189125042c952de9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a1b18e9e1ccb41a90189125042c952de9">fbCollectorSetUDPMultiSession</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector, gboolean multi_session)</td></tr>
<tr class="memdesc:a1b18e9e1ccb41a90189125042c952de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to maintain backwards compatibility with UDP.  <a href="#a1b18e9e1ccb41a90189125042c952de9">More...</a><br /></td></tr>
<tr class="separator:a1b18e9e1ccb41a90189125042c952de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efc61d324cb411b9a4c32acff0bc72c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a2efc61d324cb411b9a4c32acff0bc72c">fbCollectorManageUDPStreamByPort</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector, gboolean manage_port)</td></tr>
<tr class="memdesc:a2efc61d324cb411b9a4c32acff0bc72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attempt to fix what some netflow v9 exporters do wrong.  <a href="#a2efc61d324cb411b9a4c32acff0bc72c">More...</a><br /></td></tr>
<tr class="separator:a2efc61d324cb411b9a4c32acff0bc72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Fixbuf IPFIX protocol library public interface. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ae180698bcf1673599ce689814af51078"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_CISCO_ASA_EVENT_ID&#160;&#160;&#160;9998</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Information Element ID for Cisco NSEL Element NF_F_FW_EVENT often exported by Cisco's ASA Device. </p>
<p>This must be converted to a different Information Element ID due to the reverse IE bit in IPFIX. Cisco uses IE ID 40005. <a href="http://www.cisco.com/en/US/docs/security/asa/asa82/netflow/netflow.html">http://www.cisco.com/en/US/docs/security/asa/asa82/netflow/netflow.html</a> </p>

</div>
</div>
<a class="anchor" id="a0f1037623125ccfc4f42a08377f61ee1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_CISCO_ASA_EVENT_XTRA&#160;&#160;&#160;9997</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Information Element ID for Cisco NSEL Element NF_F_FW_EXT_EVENT often exported by Cisco's ASA Device. </p>
<p>This must be converted to a different Information Element ID due to the reverse IE bit in IPFIX. Cisco uses IE ID 33002 <a href="http://www.cisco.com/en/US/docs/security/asa/asa82/netflow/netflow.html">http://www.cisco.com/en/US/docs/security/asa/asa82/netflow/netflow.html</a> More Information about event codes can be found here: <a href="http://www.cisco.com/en/US/docs/security/asa/asa84/system/netflow/netflow.pdf">http://www.cisco.com/en/US/docs/security/asa/asa84/system/netflow/netflow.pdf</a> </p>

</div>
</div>
<a class="anchor" id="a4f6b39310e0db0215096369ffaf342e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_CONNSPEC_INIT</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ <a class="code" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338a7e8c8d5180377a3e0c466dd421a5b541">FB_SCTP</a>, NULL, NULL,         \</div><div class="line">                           NULL, NULL, NULL, NULL,      \</div><div class="line">                           NULL, NULL }</div><div class="ttc" id="public_8h_html_a42b75e3dc15f6c6ebb447598eb7d9338a7e8c8d5180377a3e0c466dd421a5b541"><div class="ttname"><a href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338a7e8c8d5180377a3e0c466dd421a5b541">FB_SCTP</a></div><div class="ttdoc">Partially reliable datagram transport via SCTP. </div><div class="ttdef"><b>Definition:</b> public.h:1546</div></div>
</div><!-- fragment -->
<p>Convenience macro defining a null static fbConnSpec_t. </p>

</div>
</div>
<a class="anchor" id="a2e0ffd43c861a9833b279557d687c57a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_BUFSZ&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A message was received larger than the collector buffer size. </p>
<p>Should never occur. This condition is checked at the transport layer in case future versions of fixbuf support dynamic buffer sizing. </p>

</div>
</div>
<a class="anchor" id="a16875886e559694c2a5d80cc1b9e00de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_DOMAIN&#160;&#160;&#160;g_quark_from_string(&quot;fixbufError&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All fixbuf errors are returned within the FB_ERROR_DOMAIN domain. </p>

</div>
</div>
<a class="anchor" id="a367b1a2c0af72830b0c9905b2db317cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_EOF&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End of IPFIX Message stream. </p>
<p>No more messages are available from the transport layer on read, either because the session has closed, or the file has been processed. </p>

</div>
</div>
<a class="anchor" id="a0259831c04ac6aeee7cb6c96d76b3d65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_EOM&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End of IPFIX message. </p>
<p>Either there are no more records present in the message on read, or the message MTU has been reached on write. </p>

</div>
</div>
<a class="anchor" id="af25725f494c04fdab230c546953bdda9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_IMPL&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The requested feature is not yet implemented. </p>

</div>
</div>
<a class="anchor" id="ac34f5cab6ec1507f9626c1501b9b8d42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_IO&#160;&#160;&#160;7</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An unspecified I/O error occured. </p>

</div>
</div>
<a class="anchor" id="aa225780afc0e4680caf26e0ec9ab2427"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_IPFIX&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Illegal IPFIX mesaage content on read. </p>
<p>The input stream is malformed, or is not an IPFIX Message after all. </p>

</div>
</div>
<a class="anchor" id="a85d583572e660442b964f967d6b4e30c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_NETFLOWV9&#160;&#160;&#160;12</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Illegal NetflowV9 content on a read. </p>
<p>Can't parse the Netflow header or the stream is not a NetflowV9 stream </p>

</div>
</div>
<a class="anchor" id="a11335d44d4833a94788908cc0e019c32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_NLREAD&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No data is available for reading from the transport layer. </p>
<p>Either a transport layer read was interrupted, or timed out. </p>

</div>
</div>
<a class="anchor" id="a6a865a476cfedc1bd762a815a919b3d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_NLWRITE&#160;&#160;&#160;9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An attempt to write data to the transport layer failed due to closure of the remote end of the connection. </p>
<p>Currently only occurs with the TCP transport layer. </p>

</div>
</div>
<a class="anchor" id="af9fea2f3d2282f4130b0762bfdf4cdc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_TMPL&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No template was available for the given template ID. </p>

</div>
</div>
<a class="anchor" id="ad5904eae4a46ffa0d02fe24e25bf8f88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_F_ALIEN&#160;&#160;&#160;0x00000080</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Information element alien flag. </p>
<p>If set, IE is enterprise-specific and was recieved via an external template at a Collecting Process. It is therefore subject to semantic typing via options (not yet implemented). Do not set this flag on information elements added programmatically to an information model via <a class="el" href="public_8h.html#ae06a524366afa6827d7e5abb1c33c0d0" title="Add a single information element to an information model. ">fbInfoModelAddElement()</a> or <a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179" title="Add multiple information elements in an array to an information model. ">fbInfoModelAddElementArray()</a>. </p>

</div>
</div>
<a class="anchor" id="a8999778f3785deb0579e458b87671832"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_F_ENDIAN&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Information element endian conversion flag. </p>
<p>If set, IE is an integer and will be endian-converted on transcode. </p>

</div>
</div>
<a class="anchor" id="a57b7a85944a72f6a16741191eb9458df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_F_NONE&#160;&#160;&#160;0x00000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default treatment flags value. </p>
<p>Provided for initializer convenience. Corresponds to octet-array semantics for a non-reversible, non-alien IE. </p>

</div>
</div>
<a class="anchor" id="af8e002cfbd82eff68afc556f9786c182"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_F_REVERSIBLE&#160;&#160;&#160;0x00000040</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Information element reversible flag. </p>
<p>If set for an information element with an enterprise number of 0 (an IETF/IANA IE), adding the information element via <a class="el" href="public_8h.html#ae06a524366afa6827d7e5abb1c33c0d0" title="Add a single information element to an information model. ">fbInfoModelAddElement()</a> or <a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179" title="Add multiple information elements in an array to an information model. ">fbInfoModelAddElementArray()</a> will cause a second, reverse information element to be added to the model following the conventions in IETF Internet-Draft draft-ietf-ipfix-biflow-03. Note that the reverse PEN has not yet been assigned, so this implementation uses a provisional reverse IE as defined by the macro FB_IE_PEN_REVERSE. </p>

</div>
</div>
<a class="anchor" id="af98543cbda640dfca398c2d077382a36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_INIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_ent_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_num_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_len_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_flags_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="public_8h.html#ac36983de4e17c281e44582a418d5477d">FB_IE_INIT_FULL</a>(_name_, _ent_, _num_, _len_, _flags_, 0, 0, 0, (char*)NULL)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for creating default fbInfoElement_t static initializers. </p>
<p>Used for creating information element arrays suitable for passing to <a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179" title="Add multiple information elements in an array to an information model. ">fbInfoModelAddElementArray()</a>. </p>

</div>
</div>
<a class="anchor" id="ac36983de4e17c281e44582a418d5477d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_INIT_FULL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_ent_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_num_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_len_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_flags_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_min_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_max_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_type_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_desc_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;{ {(const struct <a class="el" href="structfb_info_element__st.html">fbInfoElement_st</a>*)_name_}, 0, _ent_, _num_, _len_, _flags_, _min_, _max_, _type_, _desc_ }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NEW Convenience macro for creating full fbInfoElement_t static initializers. </p>
<p>Used for creating information element arrays suitable for passing to <a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179" title="Add multiple information elements in an array to an information model. ">fbInfoModelAddElementArray()</a>. </p>

</div>
</div>
<a class="anchor" id="a4e1799c19a4376b5e94a9f2c46af1af0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_PEN_REVERSE&#160;&#160;&#160;29305</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Private enterprise number for reverse information elements (see draft-ietf-ipfix-biflow-03 section 6.1). </p>
<p>If an information element with FB_IE_F_REVERSIBLE and a zero enterprise number (i.e., an IANA-assigned information element) is added to a model, the reverse IE will be generated by setting the enterprise number to this constant. </p>

</div>
</div>
<a class="anchor" id="af2a306f4cc41ea9e8d7828cd6c8023fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_REVERSE_STR&#160;&#160;&#160;&quot;reverse&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse information element name prefix. </p>
<p>This string is prepended to an information element name, and the first character after this string is capitalized, when generating a reverse information element. </p>

</div>
</div>
<a class="anchor" id="ac784ef024c2089ce88fe18db93cea70e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_REVERSE_STRLEN&#160;&#160;&#160;7</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Length of reverse information element name prefix. </p>

</div>
</div>
<a class="anchor" id="ac82de271da22fdfa0bc545bc7fb124d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_SEMANTIC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">flags</td><td>)</td>
          <td>&#160;&#160;&#160;((flags &amp; 0x0000ff00) &gt;&gt; 8)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for extracting the information element semantic value from the flags variable in the fbInfoElement_t struct. </p>

</div>
</div>
<a class="anchor" id="ad9613bc9aa4e85dc7f55d990a0e502be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_UNITS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">flags</td><td>)</td>
          <td>&#160;&#160;&#160;((flags &amp; 0xFFFF0000) &gt;&gt; 16)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro for extracting the information element units value from the flags variable in the fbInfoElement_t struct. </p>

</div>
</div>
<a class="anchor" id="ac0892f774e630526db23f2d4090817c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_VENDOR_BIT_REVERSE&#160;&#160;&#160;0x4000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse information element bit for vendor-specific information elements (see draft-ietf-ipfix-biflow-03 section 6.2). </p>
<p>If an information element with FB_IE_F_REVERSIBLE and a non-zero enterprise number (i.e., a vendor-specific information element) is added to a model, the reverse IE number will be generated by ORing this bit with the given forward information element number. </p>

</div>
</div>
<a class="anchor" id="a7f581cd8c25363d1e8bec0effec73aa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_LIST_SEM_UNDEFINED&#160;&#160;&#160;0xFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The following Semantic values are for use in the structured Data Types: basicLists, subTemplateLists, and subTemplateMultiLists. </p>
<p>Semantic field for indicating the value has not been set </p>

</div>
</div>
<a class="anchor" id="a4f11fd6c323d4d235927eaaa4d5e9bd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_UNITS_BITS&#160;&#160;&#160;0x00010000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Information Element Units - See RFC 5610. </p>
<p>An Information Element Units Flag used to describe the units of an information element. See RFC 5610 </p>

</div>
</div>
<a class="anchor" id="addc601d33669b298c15d98ccf55430ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_UNITS_ENTRIES&#160;&#160;&#160;0x000C0000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Information Element Units Flag used to describe the units of an information element. </p>
<p>See RFC 5610 </p>

</div>
</div>
<a class="anchor" id="a191d0656006408deefde2642767020d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_UNITS_FLOWS&#160;&#160;&#160;0x00040000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Information Element Units Flag used to describe the units of an information element. </p>
<p>See RFC 5610 </p>

</div>
</div>
<a class="anchor" id="a714a48e1d8c34d9cd3fbcc447e1f21a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_UNITS_FRAMES&#160;&#160;&#160;0x000D0000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Information Element Units Flag used to describe the units of an information element. </p>
<p>Recently added for layer 2 frames </p>

</div>
</div>
<a class="anchor" id="aaca3ce2320dfb6d69eb1c0c74f181bf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_UNITS_HOPS&#160;&#160;&#160;0x000B0000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Information Element Units Flag used to describe the units of an information element. </p>
<p>See RFC 5610 </p>

</div>
</div>
<a class="anchor" id="a1e1e7fd628f34f5ab51e5b3816e1257d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_UNITS_MESSAGES&#160;&#160;&#160;0x000A0000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Information Element Units Flag used to describe the units of an information element. </p>
<p>See RFC 5610 </p>

</div>
</div>
<a class="anchor" id="abba28c96ce6b4e15369c59d22e963668"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_UNITS_MICROSECONDS&#160;&#160;&#160;0x00070000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Information Element Units Flag used to describe the units of an information element. </p>
<p>See RFC 5610 </p>

</div>
</div>
<a class="anchor" id="adc03b5d75f88b606793a7a1bd466c822"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_UNITS_MILLISECONDS&#160;&#160;&#160;0x00060000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Information Element Units Flag used to describe the units of an information element. </p>
<p>See RFC 5610 </p>

</div>
</div>
<a class="anchor" id="a43f064172432cc14b1f32cf26dc8b454"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_UNITS_NANOSECONDS&#160;&#160;&#160;0x00080000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Information Element Units Flag used to describe the units of an information element. </p>
<p>See RFC 5610 </p>

</div>
</div>
<a class="anchor" id="a66ab0d8561439404d24ed7b99ccfb4bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_UNITS_OCTETS&#160;&#160;&#160;0x00020000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Information Element Units Flag used to describe the units of an information element. </p>
<p>See RFC 5610 </p>

</div>
</div>
<a class="anchor" id="a86da86544a71cb898812cebc1eb2b59f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_UNITS_PACKETS&#160;&#160;&#160;0x00030000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Information Element Units Flag used to describe the units of an information element. </p>
<p>See RFC 5610 </p>

</div>
</div>
<a class="anchor" id="a98e17b48c3f3b1eab3bddf19d4e0ae29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_UNITS_SECONDS&#160;&#160;&#160;0x00050000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Information Element Units Flag used to describe the units of an information element. </p>
<p>See RFC 5610 </p>

</div>
</div>
<a class="anchor" id="ac1a1d68de5e84267080edc3f665e3826"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_UNITS_WORDS&#160;&#160;&#160;0x00090000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Information Element Units Flag used to describe the units of an information element. </p>
<p>See RFC 5610 </p>

</div>
</div>
<a class="anchor" id="a9ee0139d4776e3b83dc6a2854752f96f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FIXBUF_CHECK_VERSION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">major, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">minor, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">release&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(FIXBUF_VERSION_MAJOR &gt; (major) || \</div><div class="line">     (FIXBUF_VERSION_MAJOR == (major) &amp;&amp; FIXBUF_VERSION_MINOR &gt; (minor)) || \</div><div class="line">     (FIXBUF_VERSION_MAJOR == (major) &amp;&amp; FIXBUF_VERSION_MINOR == (minor) &amp;&amp; \</div><div class="line">      FIXBUF_VERSION_RELEASE &gt;= (release)))</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="adbe40eb39792bfedc00d221c8c9f7a15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct fbCollector_st <a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IPFIX Collecting Process endpoint. </p>
<p>Used to collect messages into an associated IPFIX Message Buffer from a remote Exporting Process, or from an IPFIX File. Use this with the fbListener_t structure to implement a full Collecting Process, including Transport Session setup. The internals of this structure are private to libfixbuf. </p>

</div>
</div>
<a class="anchor" id="abbc3c1c84682e0e8d89280fbe828b392"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfb_conn_spec__st.html">fbConnSpec_st</a>  <a class="el" href="public_8h.html#abbc3c1c84682e0e8d89280fbe828b392">fbConnSpec_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connection specifier. </p>
<p>Used to define a peer address for fbExporter_t, or a passive address for fbListener_t. </p>

</div>
</div>
<a class="anchor" id="a054d6ae24ecc9fbc2e38e683d8a5481a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct fbExporter_st <a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IPFIX Exporting Process endpoint. </p>
<p>Used to export messages from an associated IPFIX Message Buffer to a remote Collecting Process, or to an IPFIX File. The internals of this structure are private to libfixbuf. </p>

</div>
</div>
<a class="anchor" id="a8e5e041c0ef22a30e1b916c6284cb180"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfb_info_element__st.html">fbInfoElement_st</a>  <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A single IPFIX Information Element definition. </p>
<p>An Information Element defines the type of data in each field of a record. This structure may be contained in an fbInfoModel_t, in which case the name field contians the information element name, or an an fbTemplate_t, in which case the canon field references the fbInfoElement_t contained within the Information Model. </p>

</div>
</div>
<a class="anchor" id="a77a7ed46d38bf13d31c90dbea49b97c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfb_info_element_opt_rec__st.html">fbInfoElementOptRec_st</a>  <a class="el" href="public_8h.html#a77a7ed46d38bf13d31c90dbea49b97c3">fbInfoElementOptRec_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The corresponding struct to the Information Element Type Options Template. </p>
<p>If collecting this element, use the function fbInfoElementAddOptRecElem() to add this element to the info model. </p>

</div>
</div>
<a class="anchor" id="ab31a6d6f2d24c483d1dc3d7cc8f71009"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfb_info_element_spec__st.html">fbInfoElementSpec_st</a>  <a class="el" href="public_8h.html#ab31a6d6f2d24c483d1dc3d7cc8f71009">fbInfoElementSpec_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A single IPFIX Information Element specification. </p>
<p>Used to name an information element for inclusion in a template by <a class="el" href="public_8h.html#acb8f6399ecdbbc6af8fbacedc4e49a6c" title="Append information elements described by a specifier array to a template. ">fbTemplateAppendSpecArray()</a>. </p>

</div>
</div>
<a class="anchor" id="a7403b5635628fcc24eeb03b73c0b08bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct fbInfoModel_st <a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An IPFIX information model. </p>
<p>Contains information element definitions. The internals of this structure are private to libfixbuf. </p>

</div>
</div>
<a class="anchor" id="a4265eb950b491c405d075f1510a5710e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct fbListener_st <a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IPFIX Collecting Process session listener. </p>
<p>Used to wait for connections from IPFIX Exporting Processes, and to manage open connections via a select(2)-based mechanism. The internals of this structure are private to libfixbuf. </p>

</div>
</div>
<a class="anchor" id="a301cd8ac20e8e02e05e3b279ff50a7eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fbListenerAppFree_fn) (void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Application context free function type for fbListener_t. </p>
<p>If the Collector is in multi-session mode (see appinit fn), then the appfree function will be called if a session is timed out (does not receive a UDP message for more than 30 minutes.) Called during fbCollector_t cleanup. </p>

</div>
</div>
<a class="anchor" id="a4313f40737bf2a6ab1db94693119312c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef gboolean(* fbListenerAppInit_fn) (<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener, void **ctx, int fd, struct sockaddr *peer, size_t peerlen, GError **err)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Application context initialization function type for fbListener_t. </p>
<p>This function is called after accept(2) for TCP or SCTP with the peer address in the peer argument. For UDP, it is called during fbListener_t initialization and the peer address will be NULL. If the Collector is in multi-session mode, the appinit function will be called when a new UDP connection occurs with the peer address, similiar to the TCP case. Use <a class="el" href="public_8h.html#a1b18e9e1ccb41a90189125042c952de9" title="Attempt to maintain backwards compatibility with UDP. ">fbCollectorSetUDPMultiSession()</a> to turn on multi-session mode (off by default). The application may veto fbCollector_t creation by returning FALSE. In multi-session mode, if the connection is to be ignored, the application should set error code FB_ERROR_NLREAD on the err and return FALSE. If the application returns FALSE, fixbuf will maintain information about that peer, and will reject connections from that peer until shutdown or until that session times out. Fixbuf will return FB_ERROR_NLREAD for previously rejected sessions. The context (returned via out-parameter ctx) will be stored in the fbCollector_t, and is retrievable via a call to <a class="el" href="public_8h.html#ad9fa506279884348752111ff3bb52882" title="Retrieve the application context associated with a collector. ">fbCollectorGetContext()</a>. If not in multi-session mode and using the appinit fn, the ctx will be associated with all UDP sessions. </p>

</div>
</div>
<a class="anchor" id="adf94d0c3f1d23a5eeb689c9dd3471fa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fbNewTemplateCallback_fn) (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint16_t tid, <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The callback function to be called when the session receives a new external template from the connected node. </p>
<p>The point of this callback is to be able to assign an internal template to a received external template for subTemplates or to apply some context variable to a template. The callback should be set using <a class="el" href="public_8h.html#a571e85ca2f6c01b1c94932e546b978e9" title="This function sets the callback to let the user know when a new template has arrived from the connect...">fbSessionAddTemplateCallback()</a> and that function should be called upon session creation. Libfixbuf often clones sessions upon receiving a connection (particularly in the UDP case) and this callback function is carried over to cloned sessions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>a pointer to the session that received the template </td></tr>
    <tr><td class="paramname">tid</td><td>the template ID for the template that was received </td></tr>
    <tr><td class="paramname">tmpl</td><td>pointer to the template information of the received template </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NO return value </dd></dl>

</div>
</div>
<a class="anchor" id="a8441ccbdab7eaccc081dae0e3af32855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct fbSession_st <a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An IPFIX Transport Session state container. </p>
<p>Though Session creation and lifetime are managed by the fbCollector_t and fbExporter_t types, each fBuf_t buffer uses this type to store session state, including internal and external Templates and Message Sequence Number information. </p>

</div>
</div>
<a class="anchor" id="afb88011d092a7157d3632a6d660294d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_st</a>  <a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure used to hold information of a sub template list. </p>
<p>This structure is filled in by the user in an exporter to tell fixbuf how to encode the data. This structure is filled in by the transcoder in a collector, feeding the useful information up to the user </p>

</div>
</div>
<a class="anchor" id="a21c182c97f40c7c8f213e8e090d9057a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_st</a>  <a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entries contain the same type of information at SubTemplateLists: template ID and template pointers to describe the data the number of data elements and the data pointer and data length. </p>
<p>Sub template multi lists are inherently nested constructions. At a high level, they are a list of sub template lists. The first level is a list of fbSubTemplateMultiListEntry_t's, which each contain the information that describes the data contained in them. Initializing a fbSubTemplateMultiList_t with a semantic and number of elements returns memory that contains numElements blocks of memory containing fbSubTemplateMultiListEntry_t's. It is not ready to accept data. Each of the fbSubTemplateMultiListEntry_t's needed to be set up then data is copied into the entries. </p>

</div>
</div>
<a class="anchor" id="a1a98b02ac2e3547d96e839174270af99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfb_template__st.html">fbTemplate_st</a> <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An IPFIX Template or Options Template. </p>
<p>Templates define the structure of data records and options records within an IPFIX Message. The internals of this structure are private to libfixbuf. </p>

</div>
</div>
<a class="anchor" id="a3227ccbb8c738607f1370f3176c7a05f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fbTemplateCtxCallback2_fn) (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint16_t tid, <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, void *app_ctx, void **tmpl_ctx, <a class="el" href="public_8h.html#a5bcd78cd35aa042de120c5bda82d6670">fbTemplateCtxFree2_fn</a> *fn)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback function that will be called when the session receives a new external template. </p>
<p>This callback can be used to assign an internal template to an incoming external template for nested template records using <a class="el" href="public_8h.html#a1b142aa40a63aab16b297c77649f3d5c" title="Adds an external-internal template pair to the session. ">fbSessionAddTemplatePair()</a> or to apply some context variable to a template. The fbNewTemplateCallback_fn is retained for backwards compatibility.</p>
<p>The callback should be set using <a class="el" href="public_8h.html#abd78f8739bd2c5c3984bb0b6959b99ff" title="This function sets the callback that allows the application to set its own context variable with a ne...">fbSessionAddTemplateCtxCallback2()</a> and that function should be called after <a class="el" href="public_8h.html#ace1d8a4523d098e625d5330e0d15bd4b" title="Allocate a transport session state container. ">fbSessionAlloc()</a>. Libfixbuf often clones session upon receiving a connection (particularly in the UDP case since a collector and fbuf can have multiple sessions) and this callback is carried over to cloned sessions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>a pointer to the session that received the template </td></tr>
    <tr><td class="paramname">tid</td><td>the template ID for the template that was received </td></tr>
    <tr><td class="paramname">tmpl</td><td>pointer to the template information of the received template </td></tr>
    <tr><td class="paramname">app_ctx</td><td>the app_ctx pointer that was passed to the <a class="el" href="public_8h.html#abd78f8739bd2c5c3984bb0b6959b99ff" title="This function sets the callback that allows the application to set its own context variable with a ne...">fbSessionAddTemplateCtxCallback2()</a> call </td></tr>
    <tr><td class="paramname">tmpl_ctx</td><td>pointer that is stored in the fbTemplate structure. </td></tr>
    <tr><td class="paramname">fn</td><td>a callback function that should be called to free the ctx when the template is freed/replaced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NO return value </dd></dl>

</div>
</div>
<a class="anchor" id="a6d68321e6b4bd092c974650224119cbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fbTemplateCtxCallback_fn) (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint16_t tid, <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *tmpl, void **ctx, <a class="el" href="public_8h.html#a7953f7d879b2455a59953f1758f3ca7a">fbTemplateCtxFree_fn</a> *fn)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback function that will be called when the session receives a new external template. </p>
<p>This callback can be used to assign an internal template to an incoming external template for nested template records using <a class="el" href="public_8h.html#a1b142aa40a63aab16b297c77649f3d5c" title="Adds an external-internal template pair to the session. ">fbSessionAddTemplatePair()</a> or to apply some context variable to a template. The fbNewTemplateCallback_fn is retained for backwards compatibility.</p>
<p>The callback should be set using <a class="el" href="public_8h.html#a0e20dba1b69e83a4cbd33da8b1e8bcc6" title="This function sets the callback that allows the application to set its own context variable with a ne...">fbSessionAddTemplateCtxCallback()</a> and that function should be called after <a class="el" href="public_8h.html#ace1d8a4523d098e625d5330e0d15bd4b" title="Allocate a transport session state container. ">fbSessionAlloc()</a>. Libfixbuf often clones session upon receiving a connection (particularly in the UDP case since a collector and fbuf can have multiple sessions) and this callback is carried over to cloned sessions.</p>
<p>This callback function does not provide a way for the caller to pass their application's context into the function for making a C closure. For that, use <a class="el" href="public_8h.html#abd78f8739bd2c5c3984bb0b6959b99ff" title="This function sets the callback that allows the application to set its own context variable with a ne...">fbSessionAddTemplateCtxCallback2()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>a pointer to the session that received the template </td></tr>
    <tr><td class="paramname">tid</td><td>the template ID for the template that was received </td></tr>
    <tr><td class="paramname">tmpl</td><td>pointer to the template information of the received template </td></tr>
    <tr><td class="paramname">ctx</td><td>pointer that is stored in the fbTemplate structure. </td></tr>
    <tr><td class="paramname">fn</td><td>a callback function that should be called to free the ctx when the template is freed/replaced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NO return value </dd></dl>

</div>
</div>
<a class="anchor" id="a5bcd78cd35aa042de120c5bda82d6670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fbTemplateCtxFree2_fn) (void *tmpl_ctx, void *app_ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback function that is called when a template is freed. </p>
<p>The free function should be set during the fbTemplateCtxCallback2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmpl_ctx</td><td>a pointer to the ctx that is stored within the fbTemplate. </td></tr>
    <tr><td class="paramname">app_ctx</td><td>the app_ctx pointer that was passed to the <a class="el" href="public_8h.html#abd78f8739bd2c5c3984bb0b6959b99ff" title="This function sets the callback that allows the application to set its own context variable with a ne...">fbSessionAddTemplateCtxCallback2()</a> call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NO return value </dd></dl>

</div>
</div>
<a class="anchor" id="a7953f7d879b2455a59953f1758f3ca7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fbTemplateCtxFree_fn) (void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback function that is called when a template is freed. </p>
<p>The free function should be set during the fbTemplateCtxCallback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a pointer to the ctx that is stored within the fbTemplate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NO return value </dd></dl>

</div>
</div>
<a class="anchor" id="a484fac3d07ebd24f2d165a74973be704"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338">fbTransport_en</a>  <a class="el" href="public_8h.html#a484fac3d07ebd24f2d165a74973be704">fbTransport_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transport protocol for connection specifier. </p>

</div>
</div>
<a class="anchor" id="ab1479ebe89aecd202bb628c33102129b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct fBuf_st <a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An IPFIX message buffer. </p>
<p>Used to encode and decode records from IPFIX Messages. The internals of this structure are private to libfixbuf. </p>

</div>
</div>
<a class="anchor" id="ae4c56b8891012ac69488b0a9558aaf9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfb_varfield__st.html">fbVarfield_st</a>  <a class="el" href="public_8h.html#ae4c56b8891012ac69488b0a9558aaf9e">fbVarfield_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variable-length field value. </p>
<p>Variable-length information element content is represented by an fbVarfield_t on the internal side of the transcoder; that is, variable length fields in an IPFIX Message must be represented by this structure within the application record. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a42b75e3dc15f6c6ebb447598eb7d9338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338">fbTransport_en</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transport protocol for connection specifier. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a42b75e3dc15f6c6ebb447598eb7d9338a7e8c8d5180377a3e0c466dd421a5b541"></a>FB_SCTP&#160;</td><td class="fielddoc">
<p>Partially reliable datagram transport via SCTP. </p>
<p>Only available if fixbuf was built with SCTP support. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a42b75e3dc15f6c6ebb447598eb7d9338a3d0d039b439e58056f0318fc8d40f69e"></a>FB_TCP&#160;</td><td class="fielddoc">
<p>Reliable stream transport via TCP. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a42b75e3dc15f6c6ebb447598eb7d9338a99b2804a276e4d9bb12df356a58249e2"></a>FB_UDP&#160;</td><td class="fielddoc">
<p>Unreliable datagram transport via UDP. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a42b75e3dc15f6c6ebb447598eb7d9338a0e089a579ef744ed527b20018e0d2fa9"></a>FB_DTLS_SCTP&#160;</td><td class="fielddoc">
<p>Secure, partially reliable datagram transport via DTLS over SCTP. </p>
<p>Only available if fixbuf was built with OpenSSL support. Requires an OpenSSL implementation of DLTS over SCTP, not yet available. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a42b75e3dc15f6c6ebb447598eb7d9338a26085cf8945b1127fe9aa2671544cac8"></a>FB_TLS_TCP&#160;</td><td class="fielddoc">
<p>Secure, reliable stream transport via TLS over TCP. </p>
<p>Only available if fixbuf was built with OpenSSL support. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a42b75e3dc15f6c6ebb447598eb7d9338a1adfe2d456296749abdd84cc5dcbf997"></a>FB_DTLS_UDP&#160;</td><td class="fielddoc">
<p>Secure, unreliable datagram transport via DTLS over UDP. </p>
<p>Only available if fixbuf was built with OpenSSL support. Requires OpenSSL 0.9.8 or later with DTLS support. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4d84288b9feaa32be492448b794a3697"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbBasicListAddNewElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *&#160;</td>
          <td class="paramname"><em>basicList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numNewElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an additional elememnt into the basic list must be called after calling BasicListInit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basicList</td><td>pointer to the basic list to add elements to </td></tr>
    <tr><td class="paramname">numNewElements</td><td>number of elements to add to the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly allocated element(s) </dd></dl>

</div>
</div>
<a class="anchor" id="a682b8bb11a27e75655696a565e588415"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a>* fbBasicListAlloc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocates a Basic List Structure </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer a to the allocated basic list in memory </dd></dl>

</div>
</div>
<a class="anchor" id="ae2da02e486b6f9731f33d059cc5d6eca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbBasicListClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *&#160;</td>
          <td class="paramname"><em>basicListPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the parameters of the basic list and free the data buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basicListPtr</td><td>pointer to the basic list to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a8d17288918fee8fddd4c1b37fda3d691"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbBasicListClearWithoutFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *&#160;</td>
          <td class="paramname"><em>basicList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the parameters of the basic list, but do not free the buffer. </p>
<p>This should get used when the user provides their own buffer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basicList</td><td>pointer to the basic list to clear without freeing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a86efdc19c5c10383737e0de89c97b950"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbBasicListCollectorInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *&#160;</td>
          <td class="paramname"><em>basicListPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This initializes a basic list structure for collection. </p>
<p>The key part of this function is it sets the dataPtr to NULL. If your basic list is declared as a pointer, then allocated using something like g_slice_alloc0 which sets it all to zero, you do not need to call this function. But if your basic list struct isn't a pointer, there dataPtr parameter will be set to garbage, which will break other fixbuf calls, so this function is required</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basicListPtr</td><td>pointer to the basic list to be initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="aef3712961929af50bc0900c30cbba773"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbBasicListFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *&#160;</td>
          <td class="paramname"><em>basicListPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the basic list, then free the basic list pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basicListPtr</td><td>pointer to the basic list to free </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a573bcfbfc4697838625af06884466e17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbBasicListGetDataPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *&#160;</td>
          <td class="paramname"><em>basicListPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basicListPtr</td><td>pointer to the basic list to get the data pointer from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the data held by the basic list </dd></dl>

</div>
</div>
<a class="anchor" id="acdd859fd4bc3dc5974b321f0eee2e720"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbBasicListGetIndexedDataPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *&#160;</td>
          <td class="paramname"><em>basicListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bl_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function retrieves the index'th element in the list index is 0-based. </p>
<p>Goes from 0 - (numElements-1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basicListPtr</td><td>pointer to the basic list to retrieve the dataPtr </td></tr>
    <tr><td class="paramname">bl_index</td><td>the index of the element to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the data in the index'th slot in the list, NULL if the index is past the bounds of the list </dd></dl>

</div>
</div>
<a class="anchor" id="aa7be05a5a0f8e3b16c6ac3bf1f38a982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a>* fbBasicListGetInfoElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *&#160;</td>
          <td class="paramname"><em>basicListPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a pointer to the information element used in the list it is mainly used in collectors to retrieve information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basicListPtr</td><td>pointer to the basic list to get the infoElement from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the information element from the list </dd></dl>

</div>
</div>
<a class="anchor" id="aa5cd86fbb92c002a5a29b466c759393e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbBasicListGetNextPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *&#160;</td>
          <td class="paramname"><em>basicListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>currentPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function returns the next element in the list based on the currentPtr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basicListPtr</td><td>pointer to the basic list </td></tr>
    <tr><td class="paramname">currentPtr</td><td>pointer to the current element being used. Set to NULL to retrieve the first element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the next data slot, based on the current pointer. NULL if the new pointer is passed the end of the buffer </dd></dl>

</div>
</div>
<a class="anchor" id="ab246e008d0cfe758ae98c3ac1d0342d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t fbBasicListGetSemantic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *&#160;</td>
          <td class="paramname"><em>basicListPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Semantic field for Basic List presumably used in collectors after decoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basicListPtr</td><td>pointer to the basic list to retrieve the semantic from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 8-bit semantic value describing the basic list </dd></dl>

</div>
</div>
<a class="anchor" id="a97a0558ba604ec339fc908594cdfa74f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbBasicListInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *&#160;</td>
          <td class="paramname"><em>basicListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *&#160;</td>
          <td class="paramname"><em>infoElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the basic list structure based on the parameters. </p>
<p>This function allocates a buffer large enough to hold num elements amount of the infoElements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basicListPtr</td><td>a pointer to the basic list structure to fill </td></tr>
    <tr><td class="paramname">semantic</td><td>the semantic value to be used in the basic list </td></tr>
    <tr><td class="paramname">infoElement</td><td>a pointer to the info element to be used in the list </td></tr>
    <tr><td class="paramname">numElements</td><td>number of elements in the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the memory where the list data is to be written </dd></dl>

</div>
</div>
<a class="anchor" id="ac422bc91621366c71eb467ec4181d360"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbBasicListInitWithOwnBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *&#160;</td>
          <td class="paramname"><em>basicListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *&#160;</td>
          <td class="paramname"><em>infoElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use this function to initialize the basic list, but it gets the pointer to a buffer and its length allocated independently from these functions This will generally be used by a collector that does not want to free and allocate new buffers for each incoming message </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basicListPtr</td><td>a pointer to the basic list structure to fill </td></tr>
    <tr><td class="paramname">semantic</td><td>the semantic value to be used in the basic list </td></tr>
    <tr><td class="paramname">infoElement</td><td>a pointer to the info element to be used in the list </td></tr>
    <tr><td class="paramname">numElements</td><td>number of elements in the list </td></tr>
    <tr><td class="paramname">dataLength</td><td>length of the buffer passed to the function </td></tr>
    <tr><td class="paramname">dataPtr</td><td>pointer to the buffer previously allocated for the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the beginning of the buffer on success, NULL on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a2051991d465d885437c30e886bd86c3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbBasicListRealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *&#160;</td>
          <td class="paramname"><em>basicList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>newNumElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the current data pointer, allocating a new buffer to accomodate the new number of elements. </p>
<p>The remaining parameters are unchanged. If the number of elements hasn't changed the original buffer is used and its pointer is returned </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basicList</td><td>pointer to the basic list to realloc </td></tr>
    <tr><td class="paramname">newNumElements</td><td>new number of elements to allocate for the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the data pointer for the list after realloc </dd></dl>

</div>
</div>
<a class="anchor" id="a4fcc3e9eed3d8ba2178df3212d7e77f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbBasicListSetSemantic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a> *&#160;</td>
          <td class="paramname"><em>basicListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>semantic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the semantic for describing a basic list generally used in exporters before decoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basicListPtr</td><td>pointer to the basic list to set the semantic </td></tr>
    <tr><td class="paramname">semantic</td><td>value to set the semantic field to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a7549b8dcc9e44f02187708cfb36d14bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a>* fbCollectorAllocFile </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a collecting process endpoint for a named file. </p>
<p>The underlying file will be opened immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>application context; for application use, retrievable by fbCollectorGetContext </td></tr>
    <tr><td class="paramname">path</td><td>path of file to read, or "-" to read standard input. Used to get fp, user creates and frees. </td></tr>
    <tr><td class="paramname">err</td><td>An error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a collecting process endpoint, or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a9891f65a4f6d838152b92c7afe97cc8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a>* fbCollectorAllocFP </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a collecting process endpoint for an open file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>application context; for application use, retrievable by fbCollectorGetContext </td></tr>
    <tr><td class="paramname">fp</td><td>file pointer to file to read. Created and freed by user. Must be kept around for the life of the collector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a collecting process endpoint. </dd></dl>

</div>
</div>
<a class="anchor" id="a52d8b5f0c77c81fb9c67e3509418d724"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbCollectorClearTranslator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td>
          <td class="paramname"><em>collector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fbCollectorClearTranslator </p>
<p>this removes an input translator from a given collector such that it will operate on IPFIX protocol again</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collector</td><td>the collector on which to remove the translator</td></tr>
    <tr><td class="paramname">err</td><td>when an error occurs, a Glib GError structure is set with an error description</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure </dd></dl>

</div>
</div>
<a class="anchor" id="aef460934e9c8a4fe3530cf06f66ea3cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbCollectorClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td>
          <td class="paramname"><em>collector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the file or socket underlying a collecting process endpoint. </p>
<p>No effect on open file endpoints. If the collector is attached to a buffer managed by a listener, the buffer will be removed from the listener (that is, it will not be returned by subsequent <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener. ">fbListenerWait()</a> calls).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collector</td><td>a collecting process endpoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9fa506279884348752111ff3bb52882"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbCollectorGetContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td>
          <td class="paramname"><em>collector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the application context associated with a collector. </p>
<p>This context is taken from the ctx argument of <a class="el" href="public_8h.html#a7549b8dcc9e44f02187708cfb36d14bc" title="Allocate a collecting process endpoint for a named file. ">fbCollectorAllocFile()</a> or <a class="el" href="public_8h.html#a9891f65a4f6d838152b92c7afe97cc8d" title="Allocate a collecting process endpoint for an open file. ">fbCollectorAllocFP()</a>, or passed out via the ctx argument to the appinit function argument to <a class="el" href="public_8h.html#a68a2e34a62fbfe7fe37dffa8b6b05048" title="Allocate a listener. ">fbListenerAlloc()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collector</td><td>a collecting process endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the application context </dd></dl>

</div>
</div>
<a class="anchor" id="a09cc8db0d961b61a5087c5b107b8c1eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t fbCollectorGetNetflowMissed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td>
          <td class="paramname"><em>collector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>peerlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>obdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fbCollectorGetNetflowMissed </p>
<p>Returns the number of potential missed export packets of the Netflow v9 session that is currently set on the collector (the session is set on the collector when an export packet is received) if peer is NULL. If peer is set, this will look up the session for that peer/obdomain pair and return the missed export packets associated with that peer and obdomain. If peer/obdomain pair doesn't exist, this function returns 0. This can't return the number of missed flow records since Netflow v9 increases sequence numbers by the number of export packets it has sent, NOT the number of flow records (like IPFIX and netflow v5 does).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collector</td><td></td></tr>
    <tr><td class="paramname">peer</td><td>[OPTIONAL] peer address of NetFlow v9 exporter </td></tr>
    <tr><td class="paramname">peerlen</td><td>size of peer object </td></tr>
    <tr><td class="paramname">obdomain</td><td>observation domain of NetFlow v9 exporter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of missed packets since beginning of session </dd></dl>

</div>
</div>
<a class="anchor" id="a68260b0fb1b7947f6a76152a7c4cb6c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t fbCollectorGetObservationDomain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td>
          <td class="paramname"><em>collector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the observation domain of the node connected to the UDP collector. </p>
<p>The observation domain only gets set on the collector when collecting via UDP. If the collector is using another mode of transport, use <a class="el" href="public_8h.html#a4b4577b6072c238c6d56f08555191ebb" title="Retrieve the current domain on a session. ">fbSessionGetDomain()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collector</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85c920e8f0a74ca9ea1d4a40386d673f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sockaddr* fbCollectorGetPeer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td>
          <td class="paramname"><em>collector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves information about the node connected to this collector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collector</td><td>pointer to the collector to get peer information from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to sockaddr structure containing IP information of peer </dd></dl>

</div>
</div>
<a class="anchor" id="a1d103bec199e48b0ec8a335b4f0cf3c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t fbCollectorGetSFlowMissed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td>
          <td class="paramname"><em>collector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>peerlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>obdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fbCollectorGetSFlowMissed </p>
<p>Returns the number of potential missed export packets of the SFlow session that is identified with the given ip/agentID. The agent ID is a field that is in the sFlow header and is sent with every packet. Fixbuf keeps track of sequence numbers for sFlow sessions per agent ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collector</td><td></td></tr>
    <tr><td class="paramname">peer</td><td>address of exporter to lookup </td></tr>
    <tr><td class="paramname">peerlen</td><td>sizeof(peer) </td></tr>
    <tr><td class="paramname">obdomain</td><td>observation domain of peer exporter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of missed packets since beginning of session </dd></dl>

</div>
</div>
<a class="anchor" id="a2efc61d324cb411b9a4c32acff0bc72c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbCollectorManageUDPStreamByPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td>
          <td class="paramname"><em>collector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>manage_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An attempt to fix what some netflow v9 exporters do wrong. </p>
<p>Netflow v9 rfc 3954 states that collectors should use a combination of peer IP address and observation domain to manage netflow streams. However, some devices send two separate streams on the same IP, obdomain, and the only way to differentiate is by using peer port. Turning this flag on will prevent fixbuf from zeroing out the port before comparing sockaddr structs and makes fixbuf manage streams by ip, port, and obdomain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collector</td><td>pointer to collector associated with listener. </td></tr>
    <tr><td class="paramname">manage_port</td><td>TRUE if fixbuf should manage UDP streams by port, FALSE by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac39b5a9a1eb9e8c8feaa9922cf73b300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbCollectorSetAcceptOnly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td>
          <td class="paramname"><em>collector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>address_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the collector to only receive from the given IP address over UDP. </p>
<p>The port will be ignored. Use <a class="el" href="public_8h.html#a7e64858b1a8766f7e2889b1de70fca97" title="fbListenerGetCollector ">fbListenerGetCollector()</a> to get the pointer to the collector after calling <a class="el" href="public_8h.html#a68a2e34a62fbfe7fe37dffa8b6b05048" title="Allocate a listener. ">fbListenerAlloc()</a>. ONLY valid for UDP. Set the address family in address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collector</td><td>pointer to collector </td></tr>
    <tr><td class="paramname">address</td><td>pointer to sockaddr struct with IP address and family. </td></tr>
    <tr><td class="paramname">address_length</td><td>address length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa751f591a9ae4cd4a46c57f11798a592"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbCollectorSetNetflowV9Translator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td>
          <td class="paramname"><em>collector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fbCollectorSetNetflowV9Translator </p>
<p>this sets the collector input translator to convert NetFlowV9 into IPFIX for the given collector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collector</td><td>pointer to the collector state to perform Netflow V9 conversion on </td></tr>
    <tr><td class="paramname">err</td><td>GError structure that holds the error message if an error occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on error </dd></dl>

</div>
</div>
<a class="anchor" id="a91e50cd60e8a848fcd5191da59c2bad0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbCollectorSetSFlowTranslator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td>
          <td class="paramname"><em>collector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fbCollectorSetSFlowTranslator </p>
<p>this sets the collector input translator to convert SFlow into IPFIX for the given collector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collector</td><td>pointer to the collector state to perform SFlow conversion on </td></tr>
    <tr><td class="paramname">err</td><td>GError structure that holds the error message if an error occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on error </dd></dl>

</div>
</div>
<a class="anchor" id="a1b18e9e1ccb41a90189125042c952de9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbCollectorSetUDPMultiSession </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td>
          <td class="paramname"><em>collector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>multi_session</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to maintain backwards compatibility with UDP. </p>
<p>As of version 1.2, fixbuf calls the appinit functions when a new UDP connection occurs, as opposed to calling it during fbListenerAlloc. To maintain compatibility, with old applications, fixbuf will still call appinit in fbListenerAlloc with a null peer address. If UDP multi session is turned on, it will ALSO call appinit() when a new UDP connection occurs. Likewise with appfree(). Call <a class="el" href="public_8h.html#a7e64858b1a8766f7e2889b1de70fca97" title="fbListenerGetCollector ">fbListenerGetCollector()</a> to obtain collector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collector</td><td>pointer to collector associated with listener. </td></tr>
    <tr><td class="paramname">multi_session</td><td>TRUE if multi-session enabled, FALSE by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6cf2759b8c7997a09af6c5b78af43861"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a>* fbExporterAllocBuffer </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an exporting process for a buffer. </p>
<p>The underlying buffer will be allocated to the given size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer that will be allocated and used to copy IPFIX to. </td></tr>
    <tr><td class="paramname">bufsize</td><td>size of buffer that will be allocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new exporting process endpoint </dd></dl>

</div>
</div>
<a class="anchor" id="a8b159cd95821b4382a04543f18faa279"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a>* fbExporterAllocFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an exporting process endpoint for a named file. </p>
<p>The underlying file will not be opened until the first message is emitted from the buffer associated with the exporter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>pathname of the IPFIX File to write, or "-" to open standard output. Path is duplicated and handled. Original pointer is up to the user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new exporting process endpoint </dd></dl>

</div>
</div>
<a class="anchor" id="a4055c4e29d7358629373e2be2a89a4dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a>* fbExporterAllocFP </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an exporting process endpoint for an opened ANSI C file pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>open file pointer to write to. File pointer is created and freed outside of the Exporter functions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new exporting process endpoint </dd></dl>

</div>
</div>
<a class="anchor" id="a56ccd30ae0534e838107d39769b8f9f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a>* fbExporterAllocNet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#abbc3c1c84682e0e8d89280fbe828b392">fbConnSpec_t</a> *&#160;</td>
          <td class="paramname"><em>spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an exporting process endpoint for a network connection. </p>
<p>The remote collecting process is specified by the given connection specifier. The underlying socket connection will not be opened until the first message is emitted from the buffer associated with the exporter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>remote endpoint connection specifier. A copy is made for the exporter, it is freed later. User is responsible for original spec pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new exporting process endpoint </dd></dl>

</div>
</div>
<a class="anchor" id="a809156340bdb9a1003ad57114eef5e0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbExporterAutoStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&#160;</td>
          <td class="paramname"><em>exporter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable automatic SCTP stream selection for the next message exported. </p>
<p>Automatic stream selection is the default; use this call to re-enable it on a given exporter after using <a class="el" href="public_8h.html#a8d7419bcb555dba21cba184f7ce50086" title="Set the SCTP stream for the next message exported. ">fbExporterSetStream()</a>. With automatic stream selection, the minimal behavior specified in the original IPFIX protocol (RFC xxxx) is used: all templates and options templates are exported on stream 0, and all data is exported on stream 1. This call is a no-op for non-SCTP exporters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exporter</td><td>an exporting process endpoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac91f3ef3a469b8ec03eb195e70dbc16f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbExporterClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&#160;</td>
          <td class="paramname"><em>exporter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the file or socket underlying an exporting process endpoint to close. </p>
<p>No effect on open file endpoints. The file or socket may be reopened on a subsequent message emission from the associated buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exporter</td><td>an exporting process endpoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d50a75267c63f2a3c12b2118714c16f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fbExporterGetMsgLen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&#160;</td>
          <td class="paramname"><em>exporter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the (transcoded) message length that was copied to the exporting buffer upon <a class="el" href="public_8h.html#a3def007c235fd0dccb7a2293b23341e1" title="Emit the message currently in a buffer using the associated exporting process endpoint. ">fBufEmit()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exporter</td><td>an exporting process endpoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d7419bcb555dba21cba184f7ce50086"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbExporterSetStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&#160;</td>
          <td class="paramname"><em>exporter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sctp_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the SCTP stream for the next message exported. </p>
<p>To change the SCTP stream used for export, first emit any message in the exporter's associated buffer with fbufEmit(), then use this call to set the stream for the next message. This call cancels automatic stream selection, use <a class="el" href="public_8h.html#a809156340bdb9a1003ad57114eef5e0b" title="Enable automatic SCTP stream selection for the next message exported. ">fbExporterAutoStream()</a> to re-enable it. This call is a no-op for non-SCTP exporters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exporter</td><td>an exporting process endpoint. </td></tr>
    <tr><td class="paramname">sctp_stream</td><td>SCTP stream to use for next message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7138c3a3d6df65e4b3e0ec8e236f731"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbInfoElementAddOptRecElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a77a7ed46d38bf13d31c90dbea49b97c3">fbInfoElementOptRec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an element that we received via an Options Record to the given info model. </p>
<p>Returns True if the element was successfully added. False, if it couldn't be added. This function will not add elements that have a private enterprise number of 0, for security reasons.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>An information model </td></tr>
    <tr><td class="paramname">rec</td><td>A pointer to the received fbInfoElementOptRec. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if item was successfully added to info model. </dd></dl>

</div>
</div>
<a class="anchor" id="a11f275578868dc08d2a3f8524e2cc379"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a>* fbInfoElementAllocTypeTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate the Options Template that will be used to define Information Element Type Records. </p>
<p>This function does not add the template to the session or fbuf. This function allocates the template, appends the appropriate elements to the template, and sets the scope on the template. See RFC 5610 for more info.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>A pointer to an existing info model </td></tr>
    <tr><td class="paramname">err</td><td>GError </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the newly allocated template. </dd></dl>

</div>
</div>
<a class="anchor" id="aa939fd9269e4cf11317aa8ff9fc48224"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbInfoElementWriteOptionsRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *&#160;</td>
          <td class="paramname"><em>model_ie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export an options record to the given fbuf with information element type information about the given information element. </p>
<p>See RFC 5610 for details. Use <a class="el" href="public_8h.html#a11f275578868dc08d2a3f8524e2cc379" title="Allocate the Options Template that will be used to define Information Element Type Records...">fbInfoElementAllocTypeTemplate()</a> and add the returned template to the session, before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>An existing fbuf </td></tr>
    <tr><td class="paramname">model_ie</td><td>A pointer to the information element to export type info. </td></tr>
    <tr><td class="paramname">tid</td><td>The template id of the Options Template. </td></tr>
    <tr><td class="paramname">err</td><td>GError </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if successful, FALSE if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ae06a524366afa6827d7e5abb1c33c0d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbInfoModelAddElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *&#160;</td>
          <td class="paramname"><em>ie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a single information element to an information model. </p>
<p>The information element is assumed to be in "canonical" form; that is, its ref.name field should contain the information element name. The information element and its name are copied into the model; the caller may free or reuse its storage after this call.</p>
<p>See <a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179" title="Add multiple information elements in an array to an information model. ">fbInfoModelAddElementArray()</a> for a more convenient method of statically adding information elements to information models.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>An information model </td></tr>
    <tr><td class="paramname">ie</td><td>Pointer to an information element to copy into the model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a202bfa2340263229893a38de18670179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbInfoModelAddElementArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *&#160;</td>
          <td class="paramname"><em>ie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add multiple information elements in an array to an information model. </p>
<p>The information elements are assumed to be in "canonical" form; that is, their ref.name fields should contain the information element name. Each information element and its name are copied into the model; the caller may free or reuse its storage after this call.</p>
<p>The ie parameter points to the first information element in an array, usually statically initialized with an array of FB_IE_INIT macros followed by an FB_IE_NULL macro. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>An information model </td></tr>
    <tr><td class="paramname">ie</td><td>Pointer to an IE array to copy into the model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a390f707c7decf65060f31c0dba6c2a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a>* fbInfoModelAlloc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new information model. </p>
<p>The information model will contain all the default information elements in the IANA-managed number space, and may be extended via <a class="el" href="public_8h.html#ae06a524366afa6827d7e5abb1c33c0d0" title="Add a single information element to an information model. ">fbInfoModelAddElement()</a> and <a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179" title="Add multiple information elements in an array to an information model. ">fbInfoModelAddElementArray()</a>.</p>
<p>An Information Model is required to create Templates and Sessions. Each application should have only one Information Model.</p>
<dl class="section return"><dt>Returns</dt><dd>a new Information Model </dd></dl>

</div>
</div>
<a class="anchor" id="a29af7376716e8e222e6ed7404c95a9b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint fbInfoModelCountElements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of information elements in the information model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>An information model </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of information elements in the information model </dd></dl>

</div>
</div>
<a class="anchor" id="a860639c9f5bdf973a8c303aa9f513454"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbInfoModelFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an information model. </p>
<p>Must not be called until all sessions and templates depending on the information model have also been freed; i.e., at application cleanup time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>An information model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a507dc0fe44ee38bab3fb2c29917d5d08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a>* fbInfoModelGetElementByID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the canonical information element within an information model given the information element ID and enterprise ID. </p>
<p>The returned information element is owned by the information model and must not be modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>An information model </td></tr>
    <tr><td class="paramname">id</td><td>An information element id </td></tr>
    <tr><td class="paramname">ent</td><td>An enterprise id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The named information element within the model, or NULL if no such element exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a5dc8b2e255bc36ca22abbb811bf85c20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a>* fbInfoModelGetElementByName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the canonical information element within an information model given the information element name. </p>
<p>The returned information element is owned by the information model and must not be modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>An information model </td></tr>
    <tr><td class="paramname">name</td><td>The name of the information element to look up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The named information element within the model, or NULL if no such element exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a93870e732f41f5b29e83aca0b8c73195"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbInfoModelIterInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab266edf655a9f76181c56257a79f2a9a">fbInfoModelIter_t</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an information model iterator for iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>A pointer to the iterator to initialize </td></tr>
    <tr><td class="paramname">model</td><td>An information model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79356cea24654d750f06a8206249f619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a>* fbInfoModelIterNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab266edf655a9f76181c56257a79f2a9a">fbInfoModelIter_t</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the next information element in the information model. </p>
<p>Returns NULL once all information elements have been returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>An information model iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next information element within the model, or NULL if there are no more elements. </dd></dl>

</div>
</div>
<a class="anchor" id="a13d881c33cf7b8b52de4877438f73c0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbInfoModelTypeInfoRecord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if the template contains all of the elements the RFC 5610 info element type record should contain. </p>
<p>If so, and the fbuf is in "automatic insert" mode, we'll insert the elements in our own info model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmpl</td><td>A pointer to the template </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if template contains all the info elements </dd></dl>

</div>
</div>
<a class="anchor" id="a68a2e34a62fbfe7fe37dffa8b6b05048"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a>* fbListenerAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#abbc3c1c84682e0e8d89280fbe828b392">fbConnSpec_t</a> *&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a4313f40737bf2a6ab1db94693119312c">fbListenerAppInit_fn</a>&#160;</td>
          <td class="paramname"><em>appinit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a301cd8ac20e8e02e05e3b279ff50a7eb">fbListenerAppFree_fn</a>&#160;</td>
          <td class="paramname"><em>appfree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a listener. </p>
<p>The listener will listen on a specified local endpoint, and create a new collecting process endpoint and collection buffer for each incoming connection. Each new buffer will be associated with a clone of a given session state container.</p>
<p>The application may associate context with each created collecting process endpoint, or veto a connection attempt, via a function colled on each connection attempt passed in via the appinit parameter. If this function will create application context, provide a function via the appfree parameter which will free it.</p>
<p>The fbListener_t returned should be freed by the application by calling <a class="el" href="public_8h.html#aceb413ad5afd11a0437b583f922eb70a" title="Free a listener. ">fbListenerFree()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>local endpoint connection specifier. A copy is made of this, which is freed by listener. Original pointer freeing is up to the user. </td></tr>
    <tr><td class="paramname">session</td><td>session state container to clone for each collection buffer created by the listener. Not freed by listener. Must be kept alive while listener exists. </td></tr>
    <tr><td class="paramname">appinit</td><td>application connection initiation function. Called on each collection attempt; vetoes connection attempts and creates application context. </td></tr>
    <tr><td class="paramname">appfree</td><td>application context free function. </td></tr>
    <tr><td class="paramname">err</td><td>An error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new listener, or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aceb413ad5afd11a0437b583f922eb70a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbListenerFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a listener. </p>
<p>Stops listening on the local endpoint, and frees any open buffers still managed by the listener.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>a listener </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a620984c30070a7b3a1da81d1f84d798d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbListenerFreeGroupResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#aae51a493368af916fd3bc701cb8e9383">fbListenerGroupResult_t</a> *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the fbListenerGroupResult_t returned from fbListenerGroupWait. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>fbListenerGroupResult_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing </dd></dl>

</div>
</div>
<a class="anchor" id="a7e64858b1a8766f7e2889b1de70fca97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbListenerGetCollector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> **&#160;</td>
          <td class="paramname"><em>collector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fbListenerGetCollector </p>
<p>If a collector is associated with the listener class, this will return a handle to the collector state structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>handle to the listener state </td></tr>
    <tr><td class="paramname">collector</td><td>pointer to a collector state pointer, set on return if there is no error</td></tr>
    <tr><td class="paramname">err</td><td>a GError structure holding an error message on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE on error, check err, TRUE on success </dd></dl>

</div>
</div>
<a class="anchor" id="a5b5716c8fe63a2f982e32a98eed0e38f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbListenerGroupAddListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#aa08258f227730a0c2bba1fffeac382d1">fbListenerGroup_t</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&#160;</td>
          <td class="paramname"><em>listener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a previously allocated listener to the previously allocated group. </p>
<p>The listener is placed at the head of the list</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>pointer to the allocated group to add the listener to </td></tr>
    <tr><td class="paramname">listener</td><td>pointer to the listener structure to add to the group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success. "1" if entry couldn't be allocated "2" if either of the incoming pointers are NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a68c450b3579f5a1fa3c862a647eaa704"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#aa08258f227730a0c2bba1fffeac382d1">fbListenerGroup_t</a>* fbListenerGroupAlloc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and returns a fbListenerGroup with no entries. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the created fbListenerGroup_t, or NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="acb9f0add5b127eb4f68270f56b65bc97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbListenerGroupDeleteListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#aa08258f227730a0c2bba1fffeac382d1">fbListenerGroup_t</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&#160;</td>
          <td class="paramname"><em>listener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the listener from the group. </p>
<p>IT DOES NOT FREE THE LISTENER OR THE GROUP</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>pointer to the group to remove from the listener from </td></tr>
    <tr><td class="paramname">listener</td><td>pointer to the listener to remove from the group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, and "1" if the listener is not found "2" if either of the pointers are NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a7bf69a6f957c617c392c84c7b57e195b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbListenerGroupFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#aa08258f227730a0c2bba1fffeac382d1">fbListenerGroup_t</a> *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>frees a listener group </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>fbListenerGroup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing </dd></dl>

</div>
</div>
<a class="anchor" id="a10d092063e0986f7fab4444fa0f65822"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#aae51a493368af916fd3bc701cb8e9383">fbListenerGroupResult_t</a>* fbListenerGroupWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#aa08258f227730a0c2bba1fffeac382d1">fbListenerGroup_t</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to fbListenerWait, except that is looks for connections for multiple listeners. </p>
<p>It takes a previously allocated and filled listener group. It returns a pointer to the head of a list of listenerGroupResults. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>pointer to the group of listeners to wait on </td></tr>
    <tr><td class="paramname">err</td><td>error string structure seen throughout fixbuf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the head of the listener group result list NULL on error, and sets the error string </dd></dl>

</div>
</div>
<a class="anchor" id="a7efdc23863fcb2725c6d29c575fcbaa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbListenerInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause the current or next call to fbListenerWait to unblock and return. </p>
<p>Use this from a thread or a signal handler to interrupt a blocked listener.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>listener to interrupt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc226a9f5cef7f773fe55817839179d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a>* fbListenerOwnSocketCollectorTCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an fBuf wrapped around an independently managed socket and a properly created listener for TCP connections. </p>
<p>The caller is only responsible for creating the socket. The existing collector code will close the socket and cleanup everything.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>pointer to the listener to wrap around the socket </td></tr>
    <tr><td class="paramname">sock</td><td>the socket descriptor of the independently managed socket </td></tr>
    <tr><td class="paramname">err</td><td>standard fixbuf err structure pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the fbuf for the collector. NULL if sock is 0, 1, or 2 (stdin, stdout, or stderr) </dd></dl>

</div>
</div>
<a class="anchor" id="a3048c8b45e2d66218eaf97b2c45fdea0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a>* fbListenerOwnSocketCollectorTLS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as fbListenerOwnSocketCollectorTCP but for TLS (not tested) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>pointer to the listener to wait on </td></tr>
    <tr><td class="paramname">sock</td><td>independently managed socket descriptor </td></tr>
    <tr><td class="paramname">err</td><td>standard fixbuf err structure pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the fbuf for the collector NULL if sock is 0, 1, or 2 (stdin, stdout, or stderr) </dd></dl>

</div>
</div>
<a class="anchor" id="a514187cc62c75d4ed92ae2e497d21a42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a>* fbListenerWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on a listener. </p>
<p>Accepts pending connections from exporting processes. Returns the next collection buffer with available data to read; if the collection buffer returned by the last call to <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener. ">fbListenerWait()</a> is available, it is preferred. Blocks forever (or until <a class="el" href="public_8h.html#a7efdc23863fcb2725c6d29c575fcbaa7" title="Cause the current or next call to fbListenerWait to unblock and return. ">fbListenerInterrupt()</a> is called) if no messages or connections are available.</p>
<p>To effectively use <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener. ">fbListenerWait()</a>, the application should set up an session state container with internal templates, call <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener. ">fbListenerWait()</a> to accept a first connection, then read records from the collector buffer to end of message (FB_ERROR_EOM). At end of message, the application should then call <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener. ">fbListenerWait()</a> to accept pending connections or switch to another collector buffer with available data. Note that each collector buffer returned created by <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener. ">fbListenerWait()</a> is set to automatic mode using <a class="el" href="public_8h.html#a661f4cc21e726345d3e22372af33c2d1" title="Set the automatic mode flag on a buffer. ">fBufSetAutomaticMode()</a>. To modify this behavior, call fBufSetAutomaticMode(fbuf, TRUE) on the fbuf returned from this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>a listener </td></tr>
    <tr><td class="paramname">err</td><td>An error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a collection buffer with available data, or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d0fd5679efb1df055c72cfc10189363"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a>* fbListenerWaitNoCollectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for an incoming connection, just like fbListenerWait, except that this function doesn't monitor active collectors. </p>
<p>This allows for a multi threaded application to have one thread monitoring the listeners, and one keeping track of collectors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The listener to wait for connections on </td></tr>
    <tr><td class="paramname">err</td><td>An error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a collection buffer for the new connection, NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a357399fb037ea9b0b6e0c641a8f40cec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbListValidSemantic </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>semantic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>validates the value of the semantic field, </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The value of the semantic field to be validated * </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE is valid {0xFF, 0x00-0x04}, FALSE if not </dd></dl>

</div>
</div>
<a class="anchor" id="a2e4baf6d2142eca4cb526b1e80628bf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t fbSessionAddTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a template to a session. </p>
<p>If external, adds the template to the current domain, and exports the template if the session is associated with an export buffer. Assigns the template ID given in tid, or assigns a template ID if tid is FB_TID_AUTO. If using FB_TID_AUTO, external templates start at 256 and count up, internal templates start at 65535 and count down. This is to avoid inadvertant unrelated external and internal templates having the same ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>A session state container </td></tr>
    <tr><td class="paramname">internal</td><td>TRUE if the template is internal, FALSE if external. </td></tr>
    <tr><td class="paramname">tid</td><td>Template ID to assign, replacing any current template in case of collision; or FB_TID_AUTO to assign a new tId. </td></tr>
    <tr><td class="paramname">tmpl</td><td>Template to add </td></tr>
    <tr><td class="paramname">err</td><td>An error description, set on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the template ID of the added template, or 0 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a571e85ca2f6c01b1c94932e546b978e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSessionAddTemplateCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#adf94d0c3f1d23a5eeb689c9dd3471fa4">fbNewTemplateCallback_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the callback to let the user know when a new template has arrived from the connected IPFIX node. </p>
<p>Assigning a callback here is NOT required. Not using one will cause all sub templates to be fully decoded, transcoding all information elements in the external template.</p>
<p>This function should be called after <a class="el" href="public_8h.html#ace1d8a4523d098e625d5330e0d15bd4b" title="Allocate a transport session state container. ">fbSessionAlloc()</a>. Fixbuf often clones sessions upon receiving a connection. In the TCP case, the application has access to the session right after <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener. ">fbListenerWait()</a> returns by calling <a class="el" href="public_8h.html#a0181c5c031ec9b081149d16bab6ac5e4" title="Retrieve the session associated with a buffer. ">fBufGetSession()</a>. In the UDP case, the application does not have access to the fbSession until after a call to <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer. ">fBufNext()</a> for <a class="el" href="public_8h.html#a0be7af99ed60994dbbcfbc16701a4ace" title="Retrieve the external template that will be used to read the next record from the buffer...">fBufNextCollectionTemplate()</a> and by this time the application may have already received some templates. Therefore, it is important to call this function before <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer. ">fBufNext()</a>. Any callbacks added to the session will be carried over to cloned sessions.</p>
<p>In order to add application context to a template use the newer API call <a class="el" href="public_8h.html#abd78f8739bd2c5c3984bb0b6959b99ff" title="This function sets the callback that allows the application to set its own context variable with a ne...">fbSessionAddTemplateCtxCallback2()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the session to assign the callback to </td></tr>
    <tr><td class="paramname">callback</td><td>the function to be called when a new template is received </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a0e20dba1b69e83a4cbd33da8b1e8bcc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSessionAddTemplateCtxCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a6d68321e6b4bd092c974650224119cbe">fbTemplateCtxCallback_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the callback that allows the application to set its own context variable with a new incoming template. </p>
<p>Assigning a callback is not required and is only useful if the application either needs to store some information about the template or to prevent certain nested templates from being transcoded. If the application's template contains a subTemplateMultiList or subTemplateList and the callback is not used, all incoming templates contained in these lists will be fully transcoded and the application is responsible for freeing any nested lists contained within those objects.</p>
<p>This function should be called after <a class="el" href="public_8h.html#ace1d8a4523d098e625d5330e0d15bd4b" title="Allocate a transport session state container. ">fbSessionAlloc()</a>. Fixbuf often clones sessions upon receiving a connection. In the TCP case, the application has access to the session right after <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener. ">fbListenerWait()</a> returns by calling <a class="el" href="public_8h.html#a0181c5c031ec9b081149d16bab6ac5e4" title="Retrieve the session associated with a buffer. ">fBufGetSession()</a>. In the UDP case, the application does not have access to the fbSession until after a call to <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer. ">fBufNext()</a> for <a class="el" href="public_8h.html#a0be7af99ed60994dbbcfbc16701a4ace" title="Retrieve the external template that will be used to read the next record from the buffer...">fBufNextCollectionTemplate()</a> and by this time the application may have already received some templates. Therefore, it is important to call this function before <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer. ">fBufNext()</a>. Any callbacks added to the session will be carried over to cloned sessions.</p>
<p>This function replaced the deprecated function <a class="el" href="public_8h.html#a571e85ca2f6c01b1c94932e546b978e9" title="This function sets the callback to let the user know when a new template has arrived from the connect...">fbSessionAddTemplateCallback()</a>, and should be used with the fbNewTemplateCallback_fn. This function should be used with the fbTemplateCtxCallback_fn.</p>
<p>The callback function passed to this function does not provide a way for the caller to pass their application's context into the function for making a C closure. For that, use <a class="el" href="public_8h.html#abd78f8739bd2c5c3984bb0b6959b99ff" title="This function sets the callback that allows the application to set its own context variable with a ne...">fbSessionAddTemplateCtxCallback2()</a>. (Only one of <a class="el" href="public_8h.html#a0e20dba1b69e83a4cbd33da8b1e8bcc6" title="This function sets the callback that allows the application to set its own context variable with a ne...">fbSessionAddTemplateCtxCallback()</a> and <a class="el" href="public_8h.html#abd78f8739bd2c5c3984bb0b6959b99ff" title="This function sets the callback that allows the application to set its own context variable with a ne...">fbSessionAddTemplateCtxCallback2()</a> should be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer session to assign the callback to </td></tr>
    <tr><td class="paramname">callback</td><td>the function that should be called when a new template is received </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="abd78f8739bd2c5c3984bb0b6959b99ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSessionAddTemplateCtxCallback2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a3227ccbb8c738607f1370f3176c7a05f">fbTemplateCtxCallback2_fn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>app_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the callback that allows the application to set its own context variable with a new incoming template. </p>
<p>Assigning a callback is not required and is only useful if the application either needs to store some information about the template or to prevent certain nested templates from being transcoded. If the application's template contains a subTemplateMultiList or subTemplateList and the callback is not used, all incoming templates contained in these lists will be fully transcoded and the application is responsible for freeing any nested lists contained within those objects.</p>
<p>This function should be called after <a class="el" href="public_8h.html#ace1d8a4523d098e625d5330e0d15bd4b" title="Allocate a transport session state container. ">fbSessionAlloc()</a>. Fixbuf often clones sessions upon receiving a connection. In the TCP case, the application has access to the session right after <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener. ">fbListenerWait()</a> returns by calling <a class="el" href="public_8h.html#a0181c5c031ec9b081149d16bab6ac5e4" title="Retrieve the session associated with a buffer. ">fBufGetSession()</a>. In the UDP case, the application does not have access to the fbSession until after a call to <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer. ">fBufNext()</a> for <a class="el" href="public_8h.html#a0be7af99ed60994dbbcfbc16701a4ace" title="Retrieve the external template that will be used to read the next record from the buffer...">fBufNextCollectionTemplate()</a> and by this time the application may have already received some templates. Therefore, it is important to call this function before <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer. ">fBufNext()</a>. Any callbacks added to the session will be carried over to cloned sessions.</p>
<p>This function updates and subsumes the functionality of <a class="el" href="public_8h.html#a0e20dba1b69e83a4cbd33da8b1e8bcc6" title="This function sets the callback that allows the application to set its own context variable with a ne...">fbSessionAddTemplateCtxCallback()</a> by adding an application context pointer. (Only one of <a class="el" href="public_8h.html#a0e20dba1b69e83a4cbd33da8b1e8bcc6" title="This function sets the callback that allows the application to set its own context variable with a ne...">fbSessionAddTemplateCtxCallback()</a> and <a class="el" href="public_8h.html#abd78f8739bd2c5c3984bb0b6959b99ff" title="This function sets the callback that allows the application to set its own context variable with a ne...">fbSessionAddTemplateCtxCallback2()</a> should be used.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer session to assign the callback to </td></tr>
    <tr><td class="paramname">callback</td><td>the function that should be called when a new template is received </td></tr>
    <tr><td class="paramname">app_ctx</td><td>parameter that gets passed onto the callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a1b142aa40a63aab16b297c77649f3d5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSessionAddTemplatePair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ent_tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>int_tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an external-internal template pair to the session. </p>
<p>This tells the transcoder which internal template to use for a given external template used in a sub template list, or a sub template multi list.</p>
<p>If the value of int_tid is 0, it tells fixbuf NOT to decode any list where the external template is ent_tid. This allows a collector to specify which templates that are included in lists it can handle.</p>
<p>If ent_tid and int_tid are set equal to each other, it tells the transcoder to decode all of the fields from the external template, by using the external template also as the internal template (lining up all the fields) The exception to this is if there is an existing internal template with the same template ID as the external template. In this case, the internal template with the appropriate ID will be used. To avoid this potentially unintended consequence, be careful and deliberate with template IDs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the session to add the pair to </td></tr>
    <tr><td class="paramname">ent_tid</td><td>the external template ID </td></tr>
    <tr><td class="paramname">int_tid</td><td>the internal template ID used to decode the data when the associated external template is used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a818c3ca59f631a80062a8ccc20748c2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t fbSessionAddTemplateWithMetadata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a template to the session with the provided metadata. </p>
<p>This function appends the metadata to the buffer as well as the template.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>A session state container </td></tr>
    <tr><td class="paramname">internal</td><td>TRUE if the template is internal, FALSE if external. </td></tr>
    <tr><td class="paramname">tid</td><td>Template ID to assign, replacing any current template in case of collision; or FB_TID_AUTO to assign a new tId. </td></tr>
    <tr><td class="paramname">tmpl</td><td>Template to add </td></tr>
    <tr><td class="paramname">name</td><td>Template name </td></tr>
    <tr><td class="paramname">description</td><td>Template description </td></tr>
    <tr><td class="paramname">err</td><td>error message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>template id of newly added template </dd></dl>

</div>
</div>
<a class="anchor" id="ace1d8a4523d098e625d5330e0d15bd4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a>* fbSessionAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a transport session state container. </p>
<p>The new session is associated with the given information model, contains no templates, and is usable either for collection or export.</p>
<p>Each fbExporter_t, fbListener_t, and fbCollector_t must have its own session; session state cannot be shared.</p>
<p>The fbSession_t returned by this function is not freed by calling <a class="el" href="public_8h.html#a064ee09c33f86ac3b4e87320c2ae6463" title="Free a buffer. ">fBufFree()</a> or <a class="el" href="public_8h.html#aceb413ad5afd11a0437b583f922eb70a" title="Free a listener. ">fbListenerFree()</a>. It should be freed by the application by calling <a class="el" href="public_8h.html#a4d6672c72da8b767025ff9bd5bb54a82" title="Free a transport session state container. ">fbSessionFree()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>An information model. Not freed by sessionFree. Must be freed by user after calling SessionFree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new, empty session state container. </dd></dl>

</div>
</div>
<a class="anchor" id="ac87cc16e551d18c71f3ad30e8df7ea5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbSessionEnableTemplateMetadata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a session to export template metadata as options records. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer </td></tr>
    <tr><td class="paramname">enabled</td><td>TRUE to enable template metadata export, FALSE to disable </td></tr>
    <tr><td class="paramname">err</td><td>error mesasge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="afcd6170118372b121d5979fe45825b29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbSessionEnableTypeMetadata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a session to export type information for enterprise-specific information elements as options records according to RFC 5610. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer </td></tr>
    <tr><td class="paramname">enabled</td><td>TRUE to enable type metadata export, FALSE to disable </td></tr>
    <tr><td class="paramname">err</td><td>error mesasge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a9236bdb53a94cd19bad3fef2c9bfb947"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbSessionExportTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export a single external template in the current domain of a given session. </p>
<p>Writes the template to the associated export buffer. May cause a message to be emitted if the associated export buffer is in automatic mode, or return with FB_ERROR_EOM if the associated export buffer is not in automatic mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>a session state container associated with an export buffer </td></tr>
    <tr><td class="paramname">tid</td><td>template ID within current domain to export </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e0c42fc80985c048190203257697ab6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbSessionExportTemplates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export all external templates in the current domain of a given session. </p>
<p>Writes templates to the associated export buffer. May cause a message to be emitted if the associated export buffer is in automatic mode, or return with FB_ERROR_EOM if the associated export buffer is not in automatic mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>a session state container associated with an export buffer </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d6672c72da8b767025ff9bd5bb54a82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSessionFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a transport session state container. </p>
<p>This is done automatically when freeing the listener or buffer with which the session is associated. Use this call if a session needs to be destroyed before it is associated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>session state container to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a516f525385226edde5133332c4920f6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a>* fbSessionGetCollector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve collector that was created with the session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>a session state container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fbCollector_t the collector that was created with the session </dd></dl>

</div>
</div>
<a class="anchor" id="a4b4577b6072c238c6d56f08555191ebb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t fbSessionGetDomain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the current domain on a session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>a session state container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID of the session's current observation domain </dd></dl>

</div>
</div>
<a class="anchor" id="a9a0479b2b509462b038982dc4e6d6edf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a>* fbSessionGetInfoModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fbSessionGetInfoModel </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the info model for the session </dd></dl>

</div>
</div>
<a class="anchor" id="a0bf0ea7e68b9e58aa3fe8e0fbdc1e713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a>* fbSessionGetTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a template from a session by ID. </p>
<p>If external, retrieves the template within the current domain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>A session state container </td></tr>
    <tr><td class="paramname">internal</td><td>TRUE if the template is internal, FALSE if external. </td></tr>
    <tr><td class="paramname">tid</td><td>ID of the template to retrieve. </td></tr>
    <tr><td class="paramname">err</td><td>An error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The template with the given ID, or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d63552a3f19493ec9e05c6826f3a6ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t fbSessionLookupTemplatePair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ext_tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to find a pair, uniquely identified by the external ID, and return the associated internal template ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the session used to find the pair </td></tr>
    <tr><td class="paramname">ext_tid</td><td>external template ID used to find a pair </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the internal template ID from the pair. 0 if the pair isn't found </dd></dl>

</div>
</div>
<a class="anchor" id="a26aa6df19f1e9118c957d2b2359021d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbSessionRemoveTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a template from a session. </p>
<p>If external, removes the template from the current domain, and exports a template revocation set if the session is associated with an export buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>A session state container </td></tr>
    <tr><td class="paramname">internal</td><td>TRUE if the template is internal, FALSE if external. </td></tr>
    <tr><td class="paramname">tid</td><td>Template ID to remove. </td></tr>
    <tr><td class="paramname">err</td><td>An error description, set on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ae285ec588b2c18d3e57ff92ee4090ce5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSessionRemoveTemplatePair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ext_tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove a template pair from the list this is called by fixbuf when a template is revoked from the session by the node on the other end of the connection </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer to the session to remove the pair from </td></tr>
    <tr><td class="paramname">ext_tid</td><td>the external template ID for the pair </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="ac7ebb73e4655052664d69e9b1876543d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSessionResetExternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the external state (sequence numbers and templates) in a session state container. </p>
<p>FIXME: Verify that this call actually makes sense; either that a session is reassociatable with a new collector, or that you need to do this when reassociating a collector with a connection. Once this is done, rewrite this documentation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>session state container to reset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80f2a7b352786c72e05738a5f1d4f293"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSessionSetDomain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current observation domain on a session. </p>
<p>The domain is used to scope sequence numbers and external templates. This is called automatically during collection, but must be called to set the domain for export before adding external templates or writing records.</p>
<p>Notice that a domain change does not automatically cause any associated export buffers to emit messages; a domain change takes effect with the next message started. Therefore, call <a class="el" href="public_8h.html#a3def007c235fd0dccb7a2293b23341e1" title="Emit the message currently in a buffer using the associated exporting process endpoint. ">fBufEmit()</a> before setting the domain on the buffer's associated session.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>a session state container </td></tr>
    <tr><td class="paramname">domain</td><td>ID of the observation domain to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a844df817659eb1768172b5029347c176"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbSessionSetTemplateMetadata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add template metadata for a given template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>pointer </td></tr>
    <tr><td class="paramname">tid</td><td>template id </td></tr>
    <tr><td class="paramname">name</td><td>template name </td></tr>
    <tr><td class="paramname">description</td><td>template description </td></tr>
    <tr><td class="paramname">err</td><td>error mesasge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a1974da5e6837cdfb2d0a17d7efc338ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateListAddNewElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *&#160;</td>
          <td class="paramname"><em>subTemplateList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numNewElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates space for a number of additional element in the sub template list must be called after the list has been <a class="el" href="public_8h.html#a499616fc3525e481de877d726d7ada00" title="Initializes a subTemplateList structure and alloc&#39;s the dataPtr to get a buffer able to hold numEleme...">fbSubTemplateListInit()</a>'d. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTemplateList</td><td>pointer to the sub template list </td></tr>
    <tr><td class="paramname">numNewElements</td><td>number of new elements to add to the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first newly allocated element </dd></dl>

</div>
</div>
<a class="anchor" id="a929f24a1af3566fc5a57d13ba7d520fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a>* fbSubTemplateListAlloc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a subTemplateList_t Based on how subTemplateLists will be used and set up amidst data structures, this function may never be used. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the new sub template list </dd></dl>

</div>
</div>
<a class="anchor" id="adab25ac70317a2b857ef7acea86ae582"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateListClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *&#160;</td>
          <td class="paramname"><em>subTemplateListPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears a subtemplate list struct, notably freeing the dataPtr and setting it to NULL. </p>
<p>This should be used after each call to fBufNext: If the dataPtr is not NULL in DecodeSubTemplateList, it will not allocate new memory for the new record, which could cause a buffer overflow if the new record has a longer list than the current one. An alternative is to allocate a large buffer and assign it to dataPtr on your own, then never clear it with this. Be certain this buffer is longer than needed for all possible lists </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTemplateListPtr</td><td>pointer to the sub template list to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="ad6a97dee08969e092dff301ac73766e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateListClearWithoutFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *&#160;</td>
          <td class="paramname"><em>subTemplateListPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the sub template list parameters but does not free the data ptr. </p>
<p>This is used in conjuction with STLInitOwnBuffer because that buffer is allocated at the beginning by the user and will be freed at the end by the user, outside of fixbuf api calls </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTemplateListPtr</td><td>pointer to the sub template list to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="af0f0c40ed3a5bb9f0da695f098b1d0c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateListCollectorInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *&#160;</td>
          <td class="paramname"><em>STL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a sub template list variable on a collector. </p>
<p>If the fbSubTemplateList variable is in a struct, it will likely not be set to 0's If not, the dataPtr will not be NULL, so the transcoder will not allocate the right memory for it, as it will assuming it's set up. This will break. Call this function right after declaring the struct variable that contains the fbSubTemplateList. It only needs to be called once for each STL </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">STL</td><td>pointer to the sub template list to initialize for collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="aa724aa4ec311288e02dfab42cf23c355"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateListFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *&#160;</td>
          <td class="paramname"><em>subTemplateListPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees and clears a subTemplateList struct. </p>
<p>This frees the dataPtr AND frees the memory pointed to by the subTemplateListPtr Used in conjunction with subTemplateListAlloc(), unlikely to be used </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTemplateListPtr</td><td>pointer to the sub template list to free </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a91c7e51169df7680c9db96befde9cd74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateListGetDataPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *&#160;</td>
          <td class="paramname"><em>subTemplateListPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the buffer that contains the data for the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTemplateListPtr</td><td>pointer to the STL to get the pointer from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the data buffer used by the sub template list </dd></dl>

</div>
</div>
<a class="anchor" id="abcc3c1f936517485ba2ed23945273da7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateListGetIndexedDataPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *&#160;</td>
          <td class="paramname"><em>subTemplateListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to iterate over the elements in the list by passing in a counter to indicate which element is to be returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTemplateListPtr</td><td>pointer to the STL </td></tr>
    <tr><td class="paramname">index</td><td>The index of the element to be retrieved (0-based) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the desired element. NULL if index &gt;= numElements </dd></dl>

</div>
</div>
<a class="anchor" id="aee412c835fa0ee64eb4a7fc67975e69b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateListGetNextPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *&#160;</td>
          <td class="paramname"><em>subTemplateListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>currentPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function also traverses the elements in the list by accepting a pointer to the last element the user accessed, moves it to the next element and returns a pointer to the next element. </p>
<p>A current element of NULL tells the function to return the first element in the list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTemplateListPtr</td><td>pointer to the STL to get data from </td></tr>
    <tr><td class="paramname">currentPtr</td><td>pointer to the last element accessed. NULL causes the pointer to the first element to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the next element in the list. Returns NULL if currentPtr points to the last element in the list. </dd></dl>

</div>
</div>
<a class="anchor" id="af0f68a07d50e046fde0d1cfb315ca0e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t fbSubTemplateListGetSemantic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *&#160;</td>
          <td class="paramname"><em>subTemplateListPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the semantic value from a sub template list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTemplateListPtr</td><td>pointer to the sub template list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the semantic field from the list </dd></dl>

</div>
</div>
<a class="anchor" id="a63643493a19bce4564676fbf6b0294b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a>* fbSubTemplateListGetTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *&#160;</td>
          <td class="paramname"><em>subTemplateListPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the template pointer from the list structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTemplateListPtr</td><td>pointer to the sub template list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the template used by the sub template list </dd></dl>

</div>
</div>
<a class="anchor" id="a26cd7af13bdc03147832e868ee3a648f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t fbSubTemplateListGetTemplateID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *&#160;</td>
          <td class="paramname"><em>subTemplateListPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the template ID for the template used by the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTemplateListPtr</td><td>pointer to the sub template list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the template ID used by the sub template list </dd></dl>

</div>
</div>
<a class="anchor" id="a499616fc3525e481de877d726d7ada00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateListInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *&#160;</td>
          <td class="paramname"><em>sTL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tmplID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a subTemplateList structure and alloc's the dataPtr to get a buffer able to hold numElements in the template This will mainly be used in exporters preparing to encode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sTL</td><td>pointer to the sub template list to initialize </td></tr>
    <tr><td class="paramname">semantic</td><td>the semantic value used to describe the list contents </td></tr>
    <tr><td class="paramname">tmplID</td><td>id of the template used for encoding the list data </td></tr>
    <tr><td class="paramname">tmpl</td><td>pointer to the template struct used for encoding the list data </td></tr>
    <tr><td class="paramname">numElements</td><td>number of elements in the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated buffer (location of first element) </dd></dl>

</div>
</div>
<a class="anchor" id="af107185a4e7b9bf3ca1c086f3e170831"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateListInitWithOwnBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *&#160;</td>
          <td class="paramname"><em>subTemplateList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tmplID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the subTemplateList but does not allocate a buffer. </p>
<p>It accepts a previously allocated buffer and data length and uses it. This will generally be used in collectors providing their own buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTemplateList</td><td>pointer to the sub template list to initialize </td></tr>
    <tr><td class="paramname">semantic</td><td>the semantic value used to describe the list contents </td></tr>
    <tr><td class="paramname">tmplID</td><td>id of the template used for encoding the list data </td></tr>
    <tr><td class="paramname">tmpl</td><td>pointer to the template struct used for encoding the list data </td></tr>
    <tr><td class="paramname">numElements</td><td>number of elements in the list </td></tr>
    <tr><td class="paramname">dataLength</td><td>length of the data buffer </td></tr>
    <tr><td class="paramname">dataPtr</td><td>pointer to the previously allocated data buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to that buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a2c40d213552ca0d27b9c60ce0fbc1383"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateListRealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *&#160;</td>
          <td class="paramname"><em>subTemplateList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>newNumElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the current data pointer, allocating a new buffer to accomodate the new number of elements. </p>
<p>The remaining parameters are unchanged. If the number of elements hasn't changed the original buffer is used and its pointer is returned</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTemplateList</td><td>pointer to the sub template list to realloc </td></tr>
    <tr><td class="paramname">newNumElements</td><td>value for the new number of elements for the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the data buffer after realloc </dd></dl>

</div>
</div>
<a class="anchor" id="aea90a84a945c348970d6f24694d761a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateListSetSemantic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a> *&#160;</td>
          <td class="paramname"><em>subTemplateListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>semantic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the semantic parameter of a subTemplateList. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTemplateListPtr</td><td>pointer to the sub template list </td></tr>
    <tr><td class="paramname">semantic</td><td>Semantic value for the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a37ea8ee69f101c7d787c8b64bf76c0b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a>* fbSubTemplateMultiListAddNewEntries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *&#160;</td>
          <td class="paramname"><em>STML</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numNewEntries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds entries to the multi list of entries can only be run after the list has been initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">STML</td><td>pointer to the sub template multi list </td></tr>
    <tr><td class="paramname">numNewEntries</td><td>number of entries to add to the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new entry </dd></dl>

</div>
</div>
<a class="anchor" id="a0d6ab661518dde72ba22fb8e232aa6d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a>* fbSubTemplateMultiListAlloc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a subTemplateMultiList_t Based on how subTemplateMultiLists will be used and set up amidst data structures, this function may never be used. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the new sub template multi list </dd></dl>

</div>
</div>
<a class="anchor" id="a32b01b970a85e30ab72701da7059ae57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateMultiListClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *&#160;</td>
          <td class="paramname"><em>STML</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all of the entries (frees their data pointers), then frees the memory containing the entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">STML</td><td>pointer to the sub template mutli list to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="aa0c4272a3052cbc6d6385d449f258600"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateMultiListClearEntries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *&#160;</td>
          <td class="paramname"><em>STML</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the memory used by the entries of a sub template multi list NOTE: if any of those entries contain another layer of structures, that second layer must be freed by the user, this function cannot do that. </p>
<p>example: an entry's template contains an element of type basicList. The memory used by that basicList isn't freed by this function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">STML</td><td>pointer to the sub template multi list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="ae3b007ac32c0a91bbceb9e301b0508e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateMultiListEntryAddNewElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numNewElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates space for a number of additional elements in the sub template multi list entry. </p>
<p>May only be called after the STML entry has been initialized with <a class="el" href="public_8h.html#ab3d07cd5e507e5ebac4e9ca32c776636" title="Initializes the multi list entry with the template values, and allocates the memory used by the entry...">fbSubTemplateMultiListEntryInit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>pointer to the STML entry to add additional elements to </td></tr>
    <tr><td class="paramname">numNewElements</td><td>number of new elements to add to the STML entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first newly allocated element </dd></dl>

</div>
</div>
<a class="anchor" id="aab5362c194595441d9b3cf96f1d92a0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateMultiListEntryClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory pointed to by the data buffer holding the data elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>pointer to the entry to clear the contents of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="acb3325df690ba3bff4cb9b691a5fe307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateMultiListEntryGetDataPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the data pointer for this entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>pointer to the entry to get the data pointer from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the buffer used to store data for this entry </dd></dl>

</div>
</div>
<a class="anchor" id="af1152a67d46b10b2f0a6550506f06d02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateMultiListEntryGetIndexedPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to a data element in the entry based on the index. </p>
<p>If the index is &gt;= to the number of elements in the list, NULL is returned. The elements are 0-based, so index = 0 is returns the first elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>pointer to the entry to get a data pointer from. </td></tr>
    <tr><td class="paramname">index</td><td>the number of the element in the list to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the index'th element used by the entry NULL if the index is &gt;= numElements </dd></dl>

</div>
</div>
<a class="anchor" id="a27841bb33f91bbf856c49cd1c0ee32d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a>* fbSubTemplateMultiListEntryGetTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the template pointer used to structure the data elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>pointer to the entry to get the template from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the template pointer used to describe the contents of the entry </dd></dl>

</div>
</div>
<a class="anchor" id="a87c7ce2b006144807f49d6388309d983"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t fbSubTemplateMultiListEntryGetTemplateID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the template ID for the template used to structure the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>pointer to the entry to get the template ID from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the template ID for template that describes the data </dd></dl>

</div>
</div>
<a class="anchor" id="ab3d07cd5e507e5ebac4e9ca32c776636"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateMultiListEntryInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tmplID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the multi list entry with the template values, and allocates the memory used by the entry to hold the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>pointer to the entry to initialize </td></tr>
    <tr><td class="paramname">tmplID</td><td>ID of the template used to structure the data elements </td></tr>
    <tr><td class="paramname">tmpl</td><td>pointer to the template used to structure the data elements </td></tr>
    <tr><td class="paramname">numElements</td><td>number of data elements in the entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the data buffer to be filled in </dd></dl>

</div>
</div>
<a class="anchor" id="a1bb644017749befbc7337a9839642ad5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateMultiListEntryNextDataPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>currentPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function traverses the elements in the entry by accepting a pointer to the last element the user accessed, moves it to the next element and returns a pointer to the next element. </p>
<p>A current element of NULL tells the function to return the first element in the list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>pointer to the entry to get the next element from </td></tr>
    <tr><td class="paramname">currentPtr</td><td>pointer to the last element accessed. NULL means return a pointer to the first element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the next element in the list. Returns NULL if currentPtr points to the last element in the list </dd></dl>

</div>
</div>
<a class="anchor" id="a8b35725d9ae682581eaba7bb5f1caefb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateMultiListEntryRealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>newNumElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory for the data used by the entry, then allocates a new buffer based on the size of the template and newNumElements. </p>
<p>(if numElements doesn't change, the pointer is returned without freeing and allocating)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>pointer to the entry to realloc </td></tr>
    <tr><td class="paramname">newNumElements</td><td>the new number of elements for the entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to buffer to write data to </dd></dl>

</div>
</div>
<a class="anchor" id="ab66fd48ac8abd256e4310962aa8c6728"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateMultiListFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *&#160;</td>
          <td class="paramname"><em>STML</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the multi list, then frees the memory pointed to by STML. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">STML</td><td>pointer to the sub template multi list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a2dfe6e3994cd27f0f2c2863cbc9accd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a>* fbSubTemplateMultiListGetFirstEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *&#160;</td>
          <td class="paramname"><em>STML</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the first entry in the multi list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">STML</td><td>pointer to the sub template multi list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first entry used by the list </dd></dl>

</div>
</div>
<a class="anchor" id="a8234b166da13c96cc3e70c9ca1c57ba9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a>* fbSubTemplateMultiListGetIndexedEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *&#160;</td>
          <td class="paramname"><em>STML</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a pointer to the entry of a specific index. </p>
<p>The entry indexes are zero based. NULL is returned if the index requested is too high </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">STML</td><td>pointer to the sub template mutli list </td></tr>
    <tr><td class="paramname">index</td><td>index of the entry to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index'th entry used by the list. NULL If index &gt;= numElements </dd></dl>

</div>
</div>
<a class="anchor" id="a7e320134f6cbe6bb42cf2ff353b52636"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a>* fbSubTemplateMultiListGetNextEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *&#160;</td>
          <td class="paramname"><em>STML</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a> *&#160;</td>
          <td class="paramname"><em>currentEntry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function also traverses the elements in the list by accepting a pointer to the last element the user accessed, moves it to the next element and returns a pointer to the next element. </p>
<p>A current element of NULL tells the function to return the first element in the list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">STML</td><td>pointer to the sub template multi list to get data from </td></tr>
    <tr><td class="paramname">currentEntry</td><td>pointer to the last element accessed. NULL means none have been accessed yet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the next element in the list. Returns the NULL if currentEntry points to the last entry. </dd></dl>

</div>
</div>
<a class="anchor" id="af75970c32e64a7799d61fe32be1ad5c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t fbSubTemplateMultiListGetSemantic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *&#160;</td>
          <td class="paramname"><em>STML</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the semantic paramter from the multi list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">STML</td><td>pointer to the sub template multi list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>semantic parameter describing the contents of the multi list </dd></dl>

</div>
</div>
<a class="anchor" id="a3d3c58aebb9dcb758be9fa7eef314781"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a>* fbSubTemplateMultiListInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *&#160;</td>
          <td class="paramname"><em>STML</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the multi list with semantic, numbers of elements, and allocates memory to store numElements worth of entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">STML</td><td>pointer to the sub template multi list to initialize </td></tr>
    <tr><td class="paramname">semantic</td><td>value used to describe the entries in the multi list </td></tr>
    <tr><td class="paramname">numElements</td><td>number of entries in the multi list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first uninitialized entry </dd></dl>

</div>
</div>
<a class="anchor" id="a8cbfaabfe3526969d1bb61b6b68699a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a>* fbSubTemplateMultiListRealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *&#160;</td>
          <td class="paramname"><em>STML</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>newNumEntries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the entries used by the multi list, then if newNumElements is different than numElements, frees the entries buffer and allocates a new one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">STML</td><td>pointer to the sub template mutli list </td></tr>
    <tr><td class="paramname">newNumEntries</td><td>the new number of entries for the STML </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first entry </dd></dl>

</div>
</div>
<a class="anchor" id="a4a8185ac0dfdd2535fb338bddbc4948d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateMultiListSetSemantic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a> *&#160;</td>
          <td class="paramname"><em>STML</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>semantic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the semantic field for the multi list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">STML</td><td>pointer to the sub template multi list </td></tr>
    <tr><td class="paramname">semantic</td><td>Value for the semantic field of the sub template multi list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a6dad36eadf23739de4fe77ae466c0c7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a>* fbTemplateAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new empty template. </p>
<p>The template will be associated with the given Information Model, and only able to use Information Elements defined within that Information Model. Templates may be associated with multiple sessions, with different template IDs each time, and as such are reference counted and owned by sessions. A template must be associated with at least one session or it will be leaked; each template is freed after its last associated session is freed.</p>
<p>Use <a class="el" href="public_8h.html#a06ca9d2de7767f09ddcaa50651ff5b7c" title="Append an information element to a template. ">fbTemplateAppend()</a>, <a class="el" href="public_8h.html#a3507ead494bd3957d325565c66660e79" title="Append an information element described by specifier to a template. ">fbTemplateAppendSpec()</a>, and <a class="el" href="public_8h.html#acb8f6399ecdbbc6af8fbacedc4e49a6c" title="Append information elements described by a specifier array to a template. ">fbTemplateAppendSpecArray()</a> to "fill in" a template after creating it, and before associating it with any session.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>An information model </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new, empty Template. </dd></dl>

</div>
</div>
<a class="anchor" id="a06ca9d2de7767f09ddcaa50651ff5b7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbTemplateAppend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *&#160;</td>
          <td class="paramname"><em>ex_ie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an information element to a template. </p>
<p>The information element is taken to be an example; the canonical element from the template's associated model is looked up by enterprise and element number and copied. If no information element exists in the model with the given enterprise and element number, it is copied to the model with the name "_alienInformationElement".</p>
<p>This call is intended primarily for use by fBuf_t's template reader, but can also be useful to simulate receipt of templates over the wire.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmpl</td><td>Template to append information element to </td></tr>
    <tr><td class="paramname">ex_ie</td><td>Example IE to add to the template </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a3507ead494bd3957d325565c66660e79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbTemplateAppendSpec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab31a6d6f2d24c483d1dc3d7cc8f71009">fbInfoElementSpec_t</a> *&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an information element described by specifier to a template. </p>
<p>The information element named by the specifier is copied from the template's associated model, and the length and flags are overriden from the specifier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmpl</td><td>Template to append information element to. </td></tr>
    <tr><td class="paramname">spec</td><td>Specifier describing information element to append. </td></tr>
    <tr><td class="paramname">flags</td><td>Application flags. Must match one bit of spec flags word or the append will be silently skipped. Used for building multiple templates with different information element features from a single specifier. </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="acb8f6399ecdbbc6af8fbacedc4e49a6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbTemplateAppendSpecArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab31a6d6f2d24c483d1dc3d7cc8f71009">fbInfoElementSpec_t</a> *&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append information elements described by a specifier array to a template. </p>
<p>The information elements named by the specifiers are copied from the template's associated model, and the length and flags are overriden from each specifier. The array is read until the FB_IESPEC_NULL convenience macro is encountered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmpl</td><td>Template to append information element to. </td></tr>
    <tr><td class="paramname">spec</td><td>Pointer to first specifier in specifier array to append. </td></tr>
    <tr><td class="paramname">flags</td><td>Application flags. Must contain all bits of spec flags word or the append will be silently skipped. Used for building multiple templates with different information element features from a single specifier. </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a77d6b67bc472d0c5d9519705e4762b0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbTemplateContainsAllElementsByName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab31a6d6f2d24c483d1dc3d7cc8f71009">fbInfoElementSpec_t</a> *&#160;</td>
          <td class="paramname"><em>spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a template contains at least one instance of each information element in a given information element specifier array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmpl</td><td>Template to search </td></tr>
    <tr><td class="paramname">spec</td><td>Pointer to specifier array to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the template contains all the given IEs </dd></dl>

</div>
</div>
<a class="anchor" id="a373baa2368284e89bd58b5f9643b6222"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbTemplateContainsAllFlaggedElementsByName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab31a6d6f2d24c483d1dc3d7cc8f71009">fbInfoElementSpec_t</a> *&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a template contains at least one instance of each information element in a given information element specifier array that match the given flags argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmpl</td><td>Template to search </td></tr>
    <tr><td class="paramname">spec</td><td>Pointer to specifier array to search for </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to match info elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the template contains all the given IEs </dd></dl>

</div>
</div>
<a class="anchor" id="a12f92cdd32c7b3d3b2cd868169e94df9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbTemplateContainsElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a> *&#160;</td>
          <td class="paramname"><em>ex_ie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a template contains a given information element. </p>
<p>Matches against information element private enterprise number, number, and multiple-IE index (i.e., to determine if a given template contains six instances of a given information element, set ex_ie-&gt;midx = 5 before this call).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmpl</td><td>Template to search </td></tr>
    <tr><td class="paramname">ex_ie</td><td>Pointer to an information element to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the template contains the given IE </dd></dl>

</div>
</div>
<a class="anchor" id="afefdba7c60efb314f90945a4c3871990"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbTemplateContainsElementByName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab31a6d6f2d24c483d1dc3d7cc8f71009">fbInfoElementSpec_t</a> *&#160;</td>
          <td class="paramname"><em>spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a template contains at least one instance of a given information element, specified by name in the template's information model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmpl</td><td>Template to search </td></tr>
    <tr><td class="paramname">spec</td><td>Specifier of information element to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the template contains the given IE </dd></dl>

</div>
</div>
<a class="anchor" id="ae789e65af95fb99fcab61474288104ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t fbTemplateCountElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine number of information elements in a template. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmpl</td><td>A template </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>information element count </dd></dl>

</div>
</div>
<a class="anchor" id="a0876c0ada0d62b708c7e202c18011380"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbTemplateFreeUnused </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a template if it is not currently in use by any Session. </p>
<p>Use this to clean up while creating templates in case of error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmpl</td><td>template to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57bc7e39cde4dfacfc8c85f9ace0bb6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbTemplateGetContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ctx pointer associated with a Template. </p>
<p>The ctx pointer is typically set during the template callback when the new template is received. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmpl</td><td>Template Pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ctx The application Context Pointer </dd></dl>

</div>
</div>
<a class="anchor" id="aa1404845cf5022ad6449984e9a6fa782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a>* fbTemplateGetIndexedIE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>IEindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the information element in the template referenced by the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmpl</td><td>Pointer to the template </td></tr>
    <tr><td class="paramname">IEindex</td><td>index of the information element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the information element at index IEindex, NULL if IEindex is greater than number of elements </dd></dl>

</div>
</div>
<a class="anchor" id="a363e2261bf5a74d6efe0f64b19602454"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t fbTemplateGetOptionsScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine number of scope information elements in a template. </p>
<p>The template is an options template if nonzero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmpl</td><td>A template </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scope information element count </dd></dl>

</div>
</div>
<a class="anchor" id="a9c24d42f54d9f367db257e2d0df9b451"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbTemplateSetOptionsScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>scope_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of information elements in a template that are scope. </p>
<p>This causes the template to become an options template, and must be called after all the scope information elements have been appended to the template.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmpl</td><td>Template to set scope on </td></tr>
    <tr><td class="paramname">scope_count</td><td>Number of scope information elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71b2a64c7d212e9c3562388b95b993ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a>* fBufAllocForCollection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td>
          <td class="paramname"><em>collector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new buffer for collection. </p>
<p>Associates the buffer with a given session and collecting process endpoint; these become owned by the buffer. Session and collector are freed by fBufFree. Must not be freed by user</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>a session initialized with appropriate internal templates </td></tr>
    <tr><td class="paramname">collector</td><td>an collecting process endpoint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new IPFIX message buffer, owning the session and collector, for collection use via <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer. ">fBufNext()</a> and <a class="el" href="public_8h.html#a7c89ee8cc9d536e1ceafb371513a6479" title="Read a new message into a buffer using the associated collecting process endpoint. ">fBufNextMessage()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fb7c1a2229e3e8c15c04a215c92329b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a>* fBufAllocForExport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&#160;</td>
          <td class="paramname"><em>exporter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new buffer for export. </p>
<p>Associates the buffer with a given session and exporting process endpoint; these become owned by the buffer. Session and exporter are freed by fBufFree. Must never be freed by user</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">session</td><td>a session initialized with appropriate internal and external templates </td></tr>
    <tr><td class="paramname">exporter</td><td>an exporting process endpoint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new IPFIX message buffer, owning the session and exporter, for export use via <a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6" title="Append a record to a buffer. ">fBufAppend()</a> and <a class="el" href="public_8h.html#a3def007c235fd0dccb7a2293b23341e1" title="Emit the message currently in a buffer using the associated exporting process endpoint. ">fBufEmit()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3fdaa8626ff753c5b617707698c22b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fBufAppend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>recbase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>recsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a record to a buffer. </p>
<p>Uses the present internal template set via <a class="el" href="public_8h.html#a28c6c56234351a793fd513b212bd31b8" title="Set the internal template on a buffer to the given template ID. ">fBufSetInternalTemplate()</a> to describe the record of size recsize located in memory at recbase. Uses the present export template set via <a class="el" href="public_8h.html#af6cd20b1eb9a3287f17587888ee2476b" title="Set the external template for export on a buffer to the given template ID. ">fBufSetExportTemplate()</a> to describe the record structure to be written to the buffer. Information Elements present in the external template that are not present in the internal template are transcoded into the message as zeroes. If the buffer is in automatic mode, may cause a message to be emitted via <a class="el" href="public_8h.html#a3def007c235fd0dccb7a2293b23341e1" title="Emit the message currently in a buffer using the associated exporting process endpoint. ">fBufEmit()</a> if there is insufficient space in the buffer for the record.</p>
<p>If the internal template contains any variable length Information Elements, those must be represented in the record by fbVarfield_t structures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
    <tr><td class="paramname">recbase</td><td>pointer to internal record </td></tr>
    <tr><td class="paramname">recsize</td><td>size of internal record in bytes </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. Must not be NULL, as it is used internally in automatic mode to detect message restart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a3def007c235fd0dccb7a2293b23341e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fBufEmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit the message currently in a buffer using the associated exporting process endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a064ee09c33f86ac3b4e87320c2ae6463"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fBufFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a buffer. </p>
<p>Also frees any associated session, exporter, or collector, closing exporting process or collecting process endpoint connections and removing collecting process endpoints from any listeners, as necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04878018c9b5d07cf7bae316da654007"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a>* fBufGetCollectionTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>ext_tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the external template used to read the last record from the buffer. </p>
<p>If no record has been read, returns NULL. Stores the external template ID within the current domain in ext_tid, if not NULL.</p>
<p>This routine is not particularly useful to applications, as it would be called after the record described by the external template had been transcoded, and as such could not be used to select an appropriate internal template for a given external template. However, it is used by <a class="el" href="public_8h.html#a0be7af99ed60994dbbcfbc16701a4ace" title="Retrieve the external template that will be used to read the next record from the buffer...">fBufNextCollectionTemplate()</a>, and may be useful in certain contexts, so is made public.</p>
<p>Usually, you'll want to use <a class="el" href="public_8h.html#a0be7af99ed60994dbbcfbc16701a4ace" title="Retrieve the external template that will be used to read the next record from the buffer...">fBufNextCollectionTemplate()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
    <tr><td class="paramname">ext_tid</td><td>pointer to external template ID storage, or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the external template describing the last record read. </dd></dl>

</div>
</div>
<a class="anchor" id="a1557695deee79d0e3d053b2eda559aa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a>* fBufGetCollector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the collecting process endpoint associated with a buffer. </p>
<p>The buffer must have been allocated with <a class="el" href="public_8h.html#a71b2a64c7d212e9c3562388b95b993ab" title="Allocate a new buffer for collection. ">fBufAllocForCollection()</a>; otherwise, returns NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated collecting process endpoint </dd></dl>

</div>
</div>
<a class="anchor" id="aa1569a4ca87dc52a3bb70082a2f79eb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a>* fBufGetExporter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the exporting process endpoint associated with a buffer. </p>
<p>The buffer must have been allocated with <a class="el" href="public_8h.html#a2fb7c1a2229e3e8c15c04a215c92329b" title="Allocate a new buffer for export. ">fBufAllocForExport()</a>; otherwise, returns NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated exporting process endpoint </dd></dl>

</div>
</div>
<a class="anchor" id="a5bd3a50bb441990a1d9ae7483595578b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t fBufGetExportTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the export time on the message currently in a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the export time in epoch seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a0181c5c031ec9b081149d16bab6ac5e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a>* fBufGetSession </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the session associated with a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated session </dd></dl>

</div>
</div>
<a class="anchor" id="aaa42fa37b56ab10897b0374360d1a401"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fBufInterruptSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupts the select call of a specific collector by way of its fBuf. </p>
<p>This is mainly used by fbListenerInterrupt to interrupt all of the collector sockets well. </p>

</div>
</div>
<a class="anchor" id="a6611536bb1193747e0098f5497be821f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fBufListFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a> *&#160;</td>
          <td class="paramname"><em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>record</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all of the memory that fixbuf allocated during transcode of this record. </p>
<p>This will free all of the memory allocated for list structures when fixbuf was encoding or decoding the record. The template provided is the internal template that was set on the fBuf before <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer. ">fBufNext()</a> or <a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6" title="Append a record to a buffer. ">fBufAppend()</a> was called with the data. The template MUST match the record or bad things WILL happen without indication. This does not free the record itself. It will only free any list information elements and nested list information elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">template</td><td>pointer to the internal template that MUST match the record </td></tr>
    <tr><td class="paramname">record</td><td>pointer to the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a11c40f1d55e2d4b29b40eb4c07ce5ee7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fBufNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>recbase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>recsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a record from a buffer. </p>
<p>Uses the external template taken from the message to read the next record available from a data set in the message. Copies the record to a buffer at recbase, with a maximum record size pointed to by recsize, described by the present internal template set via <a class="el" href="public_8h.html#a28c6c56234351a793fd513b212bd31b8" title="Set the internal template on a buffer to the given template ID. ">fBufSetInternalTemplate()</a>. Reads and processes any templates and options templates between the last record read (or beginning of message) and the next data record. Information Elements present in the internal template that are not present in the external template are transcoded into the record at recbase as zeroes. If the buffer is in automatic mode, may cause a message to be read via <a class="el" href="public_8h.html#a7c89ee8cc9d536e1ceafb371513a6479" title="Read a new message into a buffer using the associated collecting process endpoint. ">fBufNextMessage()</a> if there are no more records available in the message buffer.</p>
<p>If the internal template contains any variable length Information Elements, those must be represented in the record at recbase by fbVarfield_t structures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
    <tr><td class="paramname">recbase</td><td>pointer to internal record buffer; will contain record data after call. </td></tr>
    <tr><td class="paramname">recsize</td><td>On call, pointer to size of internal record buffer in bytes. Contains number of bytes actually transcoded at end of call. </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. Must not be NULL, as it is used internally in automatic mode to detect message restart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a0be7af99ed60994dbbcfbc16701a4ace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a>* fBufNextCollectionTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>ext_tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the external template that will be used to read the next record from the buffer. </p>
<p>If no next record is available, returns NULL. Stores the external template ID within the current domain in ext_tid, if not NULL. Reads and processes any templates and options templates between the last record read (or beginning of message) and the next data record. If the buffer is in automatic mode, may cause a message to be read via <a class="el" href="public_8h.html#a7c89ee8cc9d536e1ceafb371513a6479" title="Read a new message into a buffer using the associated collecting process endpoint. ">fBufNextMessage()</a> if there are no more records available in the message buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
    <tr><td class="paramname">ext_tid</td><td>pointer to external template ID storage, or NULL. </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. Must not be NULL, as it is used internally in automatic mode to detect message restart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the external template describing the last record read. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c89ee8cc9d536e1ceafb371513a6479"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fBufNextMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a new message into a buffer using the associated collecting process endpoint. </p>
<p>Called by <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer. ">fBufNext()</a> on end of message in automatic mode; should be called after an FB_ERROR_EOM return from fBufNext in manual mode, or to skip the current message and go on to the next in the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
    <tr><td class="paramname">err</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aee3090cf1b7d116077bb9b627d622fb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fBufRemaining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the length of the buffer that is remaining after processing. </p>
<p>An IPFIX collector that is not using fixbuf to handle connections would use this function upon receiving an FB_ERROR_BUFSZ error to determine how many bytes are left in the buffer (set by fBufSetBuffer) that are not processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of buffer not read </dd></dl>

</div>
</div>
<a class="anchor" id="ad4eccf26f7c201064a730728e9a5f9bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fBufSetAutomaticInsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the automatic insert flag on a buffer. </p>
<p>In automatic insert mode, any information element type records that are collected, will automatically be inserted into the information model that is set on the fbuf's session. This allows an application to retrieve information about a non-standard information. This should be called after the fbuf is created. This function creates the internal template for the Info Element Type Record and adds it to the session.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
    <tr><td class="paramname">err</td><td>Gerror pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE if the internal template could not be created </dd></dl>

</div>
</div>
<a class="anchor" id="a661f4cc21e726345d3e22372af33c2d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fBufSetAutomaticMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&#160;</td>
          <td class="paramname"><em>automatic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the automatic mode flag on a buffer. </p>
<p>In automatic mode, a call to <a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6" title="Append a record to a buffer. ">fBufAppend()</a> or <a class="el" href="public_8h.html#a4e0c42fc80985c048190203257697ab6" title="Export all external templates in the current domain of a given session. ">fbSessionExportTemplates()</a> that overruns the available space in the buffer will cause a call to <a class="el" href="public_8h.html#a3def007c235fd0dccb7a2293b23341e1" title="Emit the message currently in a buffer using the associated exporting process endpoint. ">fBufEmit()</a> to emit the message in the buffer to the exporter before starting a new message; and a call to <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer. ">fBufNext()</a> that overruns the buffer will cause a call to <a class="el" href="public_8h.html#a7c89ee8cc9d536e1ceafb371513a6479" title="Read a new message into a buffer using the associated collecting process endpoint. ">fBufNextMessage()</a> to read another message from the collector before attempting to read a record. In manual mode, end of message on any buffer read/write call results in FB_ERROR_EOM. Buffers are created in automatic mode by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
    <tr><td class="paramname">automatic</td><td>TRUE for this buffer to be automatic, FALSE for manual. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28f24bbb227eb0f2fdd444c8754d9642"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fBufSetBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a buffer on an fBuf for collection. </p>
<p>This can be used by applications that want to handle their own connections, file reading, etc. This call should be made after the call to read and before calling fBufNext. fBufNext will return FB_ERROR_BUFSZ when there is not enough buffer space to read a full IPFIX message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
    <tr><td class="paramname">buf</td><td>the data buffer to use for processing IPFIX </td></tr>
    <tr><td class="paramname">buflen</td><td>the length of IPFIX data in buf </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae808992140071be1ccbb258ea012efd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fBufSetCollector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&#160;</td>
          <td class="paramname"><em>collector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associate an collecting process endpoint with a buffer. </p>
<p>The collector will be used to read IPFIX messgaes from a transport. The collector becomes owned by the buffer; any previous collector associated with the buffer is closed if necessary and freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
    <tr><td class="paramname">collector</td><td>an collecting process endpoint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbcd8b28b9e9e51c1a0ce342024b86ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fBufSetExporter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&#160;</td>
          <td class="paramname"><em>exporter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associate an exporting process endpoint with a buffer. </p>
<p>The exporter will be used to write IPFIX messgaes to a transport. The exporter becomes owned by the buffer; any previous exporter associated with the buffer is closed if necessary and freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
    <tr><td class="paramname">exporter</td><td>an exporting process endpoint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6cd20b1eb9a3287f17587888ee2476b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fBufSetExportTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ext_tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the external template for export on a buffer to the given template ID. </p>
<p>The external template describes the record that will be written to the IPFIX message. The buffer must be initialized for export. The given ID is scoped to the observation domain of the associated session (see <a class="el" href="public_8h.html#a80f2a7b352786c72e05738a5f1d4f293" title="Set the current observation domain on a session. ">fbSessionSetDomain()</a>), and must identify a current external template for the current domain in the buffer's associated session.</p>
<p>An export template must be set on a buffer before calling <a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6" title="Append a record to a buffer. ">fBufAppend()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
    <tr><td class="paramname">ext_tid</td><td>template ID of the new external template within the current domain. </td></tr>
    <tr><td class="paramname">err</td><td>An error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aff8d9e237f95baf75040575af0df2962"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fBufSetExportTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>extime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the export time on the message currently in a buffer. </p>
<p>This will be used as the export time of the message created by the first call to <a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6" title="Append a record to a buffer. ">fBufAppend()</a> after the current message, if any, is emitted. Use 0 for the export time to cause the export time to be taken from the system clock at message creation time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
    <tr><td class="paramname">extime</td><td>the export time in epoch seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28c6c56234351a793fd513b212bd31b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fBufSetInternalTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&#160;</td>
          <td class="paramname"><em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>int_tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the internal template on a buffer to the given template ID. </p>
<p>The internal template describes the format of the record pointed to by the recbase parameter to <a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6" title="Append a record to a buffer. ">fBufAppend()</a> (for export) and <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer. ">fBufNext()</a> (for collection). The given template ID must identify a current internal template in the buffer's associated session.</p>
<p>An internal template must be set on a buffer before calling <a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6" title="Append a record to a buffer. ">fBufAppend()</a> or <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer. ">fBufNext()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbuf</td><td>an IPFIX message buffer </td></tr>
    <tr><td class="paramname">int_tid</td><td>template ID of the new internal template </td></tr>
    <tr><td class="paramname">err</td><td>An error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
      </div><!-- l-content -->
      <div id="l-footer">&copy; 2006-2017 Carnegie Mellon University</div>
    </div><!-- p-body -->
</body>
</html>   
